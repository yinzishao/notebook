# 分区表

Q: 什么是分区表, 是么场合下可以用到分区查询优化, 分区表的限制和缺点

A: 这个过程是**将一个表或者索引物分解为多个更小、更可管理的部分**。就访问数据库的应用而言，从逻辑上讲，只有一个表或者一个索引，但是在物理上这个表或者索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。

## OLAP VS OLTP
**对于OLAP的应用**，**分区的确可以很好地提高查询的性能**，因为OLAP应用的大多数查询需要频繁地扫描一张很大的表。假设有一张1亿行的表，其中有一个时间戳属性列。你的查询需要从这张表中获取一年的数据。如果按时间戳进行分区，则**只需要扫描相应的分区即可**。

**对于OLTP的应用**，分区应该非常小心。在这种应用下，不可能会获取一张大表中10%的数据，大部分都是通过索引返回几条记录即可。而根据B+树索引的原理可知，对于一张大表，**一般的B+树需要2～3次的磁盘IO**（到现在我都没看到过4层的B+树索引）。因此B+树可以很好地完成操作，不需要分区的帮助，并且**设计不好的分区会带来严重的性能问题**。

很多开发团队会认为含有1000万行的表是一张非常巨大的表，所以他们往往会选择采用分区，如对主键做10个HASH的分区，这样每个分区就只有100万行的数据了，因此查询应该变得更快了，如`SELECT * FROM TABLE WHERE PK=@pk`。但是有没有考虑过这样一个问题：100万行和1000万行的数据**本身构成的B+树的层次都是一样的**，可能都是2层？那么上述**走主键分区的索引并不会带来性能的提高**。是的，即使1000万行的B+树的高度是3，100万行的B+树的高度是2，那么上述走主键分区的索引可以避免1次IO，从而提高查询的效率。嗯，这没问题，但是这张表**只有主键索引，而没有任何其他的列需要查询**？如果还有类似如下（**查询非聚簇索引的时候，不能过滤分区**）的语句SQL：`SELECT * FROM TABLE WHERE KEY=@key`，这时对于KEY的查询需要扫描所有的10个分区，即使每个分区的查询开销为2次IO，则一共需要20次IO。而对于原来单表的设计，对于KEY的查询还是2～3次IO。

> 对于分区来说，能减少B+树的层次，减少数据的量级。但是如果是OLTP、或者无法进行分区过滤的查询，会因为分区的IO次数更高导致速度更慢。

> 分区还有一个优势是方便数据的管理与淘汰

- [InnoDB的分区表](https://www.cnblogs.com/wade-luffy/p/6292294.html)
