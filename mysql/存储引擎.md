# 存储引擎

## InnoDB存储引擎

Q: MySQL Engine 有哪些, InnoDB存储引擎的特点

A:

1. MyISAM: 该存储引擎存储占用的空间相对与InnoDB存储引擎来说会少很多，但其支持的为**表锁，其并发性能会低很多，而且不支持事务，通常只应用于只读模式的应用**。它是MySQL最原始的存储引擎。
2. InnoDB：支持**事务操作**(如 begin， commit，rollback命令)，支持**行级锁**，行级锁相对于表锁，其粒度更细，多版本并发控制,**允许并发量更大**, **支持AUTO_INCREMENT, 支持外键**。缺点**是读写效率较差，占用的数据空间相对较大**。


## Innodb特性

### 插入缓存

当一个表有非聚集索引时，对于非聚集索引的叶子节点的**插入不是顺序的**，这时候**需要离散的访问非聚集索引页**，性能就在这里降低了，这是由于b+树的原理导致的。插入缓存就是用来解决这个问题的。

对于**非聚集索引的插入和更新**操作，**不是每一次都直接插入索引页**，而是先**判断**插入的非聚集索引页是否在缓存中，如果在就直接插入，如果不在就放入到**一个插入缓冲区**中，好似欺骗数据库这个非聚集索引已经插入到叶子节点了。然后再以**一定的频率插入缓存和非聚集索引页子节点的合并操作**。

插入缓存的使用需要满足以下两个条件(也就是非唯一的辅助索引)：**索引是辅助索引；索引不是唯一的**。

> 插入缓存的目的： 插入不是顺序时，减少离散访问非聚簇索引页。不是直接插入索引页，而是插入缓冲区，后再合并。

> 插入缓存的条件：索引是辅助索引；索引不是唯一的

### 两次写

原因： 重做日志会损坏。

两次写给innodb带来的是**可靠性**，主要用来解决**部分写失败**(partial page write)。在应用重做日志之前，我们需要一个页的副本，当写入失效发生时，**先通过页的副本来还原该页，再进行重做**，这就是doublewrite。

> doublewrite页的副本是连续的，doublewrite buffer中的页写入各个表空间文件，此时的写入则是离散的

doublewrite有两部分组成，一部分是内存中的doublewrite buffer，大小为2M，另外一部分就是物理磁盘上的共享表空间中联系的128个页，即两个区，大小同样为2M。当缓冲池的张也刷新时，并不直接写硬盘，而是会通过memcpy函数**将脏页先拷贝到内存中的doublewrite buffer**，之后通过doublewrite buffer再分两次写，每次**写入1M到共享表空间的物理磁盘上**，然后马上**调用fsync函数，同步磁盘**，避免缓冲写带来的问题。

> ? TODO: 再详细些

### 自适应哈希索引
由于innodb不支持hash索引，但是在某些情况下hash索引的效率很高，于是出现了 adaptive hash index功能，innodb存储引擎会**监控对表上索引的查找，如果观察到建立hash索引可以提高性能的时候，则自动建立hash索引**。

#### 原理解析: Adaptive Hash Index 是如何建立的
- [原理解析: Adaptive Hash Index 是如何建立的](https://mp.weixin.qq.com/s/EUWXg9zbAljF0xbFOQBRyw)

盘点一下 AHI 的运维：
- innodb_adaptive_hash_index_parts。凡是缓存都会涉及多个缓存消费者间的锁竞争。MySQL 通过设立多个 AHI 分区，每个分区使用独立的锁，来减少锁竞争。
- SHOW ENGINE INNODB STATUS。其中有 AHI 的**每个分区的使用率和 AHI 的命中率**。如果你的业务 AHI 使用率过低，理解了 AHI 建立的原理后，就可以分析该业务为何不命中 AHI，来判断业务是否合理，是否需要改变访问模式或者将数据冷热隔离。也可以考虑关闭 AHI，减少 AHI 的维护成本。

### 预读（？）
为提高读取性能，InnoDB采用**预读取方式将所需数据读入内存**，包括**随机预读取** random read ahead 和**线性预读取** linear read ahead。从innodb plugin 1.0.4开始，**随机访问预读被关闭了**，因为经常引起性能问题。但是线性预读还是保留了，并且加入了innodb_read_ahead_threshold参数。默认是56，**也就是说如果一个区(64页)的56个页都被访问过，且访问模式是顺序的，那么预读下一个区中所有的页**。

- [预读](https://idlesummerbreeze.wordpress.com/2014/09/09/mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%8C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/)

### 异步IO
比如用户发出了一条索引扫描的查询，那么这条sql可能**扫描多个索引页**，也就是需要进行**多次IO操作**，在**每扫描一个页并等待其结束才能扫描下一个页**，这是没有必要的，异步IO就是用户发出一个IO请求后可以立即发出下一个请求，所有**请求发送完毕后等待所有IO操作的完成**，这就是AIO。

异步 IO：InnoDB 中，read ahead(**预读**) 方式的读取时通过 AIO 完成的，**脏页的刷新**也是通过 AIO 完成的。

### 刷新领接页
当**刷新一个临近页**时，会检测**该页所在的区是否有别的脏页**，若有则放入一个 IO 操作刷新。这样做的好处是可以**将多次IO操作合并为一个IO**。


> 思考这些特性对业务的联系？

---
# TODO 事务原理

如何保证一致性

Redo Log（重做日志）和Undo Log


---

> 按照我个人的理解，在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。

[数据库事务原子性、一致性是怎样实现的？ - 左轻侯的回答 - 知乎](https://www.zhihu.com/question/30272728/answer/72476703)

