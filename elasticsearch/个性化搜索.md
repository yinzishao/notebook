# 个性化搜索

## 拆词规律

要点：

- **minimum_should_match控制匹配的关系度**。

- 根据查询语句的进行分词分析，获取得到长度。并根据长度进行规则匹配，超过多少命中定义自定义。来进行长短词语的匹配。

- 对某些字段需要进行完全匹配。故字段是会有**多个分词器**(keyword、ik_max)，用做不同的匹配场景。

- raw查询提高召回率，完全匹配。单字拆分，召回一些不是词库词的一些样本。例子见下。

- 各个字段权重不一样， **权重的规则说明**，验收阶段提供一些语法糖方便验收。查询关键词后面进行权重的自定义语法。

- 分步查询，脚本评分权重。优点：解耦。缺点：逻辑复杂，慢。

- best_fields, most_fields, corss_fields

- match_phrase 完全短语匹配，**slop步长，越近越好 只是should提高权重贡献**

---
## raw
一些特殊的例子，造成的原因是什么，如何进行优化的。

- **完整匹配需要raw的pharse**
- 完整匹配，raw。单个字段多个分词器。
- with_positions_offsets

如果不用raw，会有这样的情况： ”修护晚霜“ 搜"修护晚"不出来.

原因： 修护晚霜 拆词为 "修护", "晚霜" 而 修护晚 拆词为 "修护", "晚" 故无法短语匹配成功

以此进行召回率的提高


## 自定义权重
权重的规则说明，验收阶段提供一些语法糖方便验收。查询关键词后面进行权重的自定义语法

## 分步查询
跨index的查询，脚本权重

## 高亮
遇到了什么问题，为什么高亮不显示了，如何解决的，

分步查询也需要提供相应的分步高亮，获取得到相关的高亮信息。如果查询权重的时候获取得到高亮结果进行存储，占用空间较大。故得到分页id后进行再次高亮查询。

- [highlight异常、重叠不高亮](./问题记录.md)
- [fvh不支持跨度查询问题](./高亮.md)

---
# 规则

输入的搜索词都会进行拆词，拆词后的词个数
（1）1-2个，则**完全匹配**；
（2）3-9个词，则**匹配60%**，四舍五入。例如8个词，`8*60%=4.8`，则需要匹配5个词以上才返回结果
（3）10个词，则**匹配x-3个词**。例如10个词，则需要匹配`10-3=7`个词，才返回结果

优化点： **超过X个字,并且分词结果不都为1, 才使用自定义匹配。避免都是单字，筛选获取得到的很多无关的场景，步长过大且无关。**

> 拆词后分词结果为1，直接完全匹配

- https://conf.umlife.net/pages/viewpage.action?pageId=74747637

---
# 要点

精确匹配模式则直接返回完全匹配。

少于或等于2长度的进行完成匹配。

**超过X个字,并且分词结果不都为1,使用自定义匹配。避免都是单字，筛选获取得到的很多无关的场景， 步长过大且无关。**

支持模糊查询也支持完整匹配，且会把**完整匹配的权重调得很高**，让其往前返回查询。

某些字段，例如开发商公司完全匹配，完全匹配规则是通过raw进行匹配，是使用**standard的单字分词方式**

支持多个字段cross_field查询

支持跨索引的分步查询，并且附带权重。先查一个index的索引，得到相关的结果和分数。然后通过脚本权重传递到下一个需要查询的index。

特殊例子： ocr_image、ocr_video(默认是keyword)
- 查询文字根据whitespace词库拆词，但是匹配的默认keyword的分词
- 查询文字根据ik_max_word词库拆词，但是匹配的默认keyword的分词

whitespace目的是为了支持 "A B" 这样的关键词，能进行拆分匹配。提高召回率，否则的话会比较难
> ik_max_words也是能拆空格的？这里的ocr例子忘了之前是怎么想的了。

ik_max_words是为了避免默认的keyword的大小写不区分问题。
