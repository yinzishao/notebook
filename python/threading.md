
#　threading.RLock

重入锁必须由获取它的线程释放。一旦一个线程获得了一个重入锁，这个线程可以再次获得它而不阻塞;线程必须在每次获取它时释放它一次

# threading.Semaphore

s.acquire(blocking)：获取信号量。如果内部计数器大于0，此方法将把它的值减1。

然后立即返回。如果它的值为0，此方法将阻塞，直到另一个线程调用release()方法为止。

blocking参数的行为与Lock和RLock对象中描述的相同。

s.release()：通过将内部计数器的值加1来释放一个信号量。

如果计数器为0，而且另一个线程正在等待，该线程讲被唤醒。

如果有多个线程正在等待，只能从它的acquire()的调用中返回一个，并且顺序不确定。

读写锁。 读写锁与一般锁最大的区别是对同一共享资源**多个线程的读取行为是并行的**，**同时保持该资源同一时刻只能由一个写进程独占**，且写请求相对读请求**有更高的优先级**以防止writer starvation。( 一般锁同一时刻只能由一个线程独占，不论是读进程还是写进程， 即读写都是串行的，而读写锁读是并行的，写是串行的。)

读写锁的特点是：
- 当且仅当 锁没有被写进程占用且没有写请求时，可以获得读权限锁
- 当且仅当 锁没有被占用且没有读写请求时，可以获得写权限锁

## RWLock

[django.utils.synch.RWLock源码](https://github.com/django/django/blob/stable/1.11.x/django/utils/synch.py#L13)

- 读进：当前没有当前写的，和等待写的时候，当前读+1，释放读锁．获取读锁。否则等待读 +1．获取读锁。
- 读离：当前读-1, 先看还有等待读（没有也不需要进行锁的释放操作，正常结束流程。），没有才看看是不是有等待写，如果有，进行写操作，当前写+1，等待写-1．释放写锁。优先读，才到写。
- 写进：如果没有当前写，等待写，当前读，才允许写，当前写+1，释放写锁，获取写锁。否则等待写+1， 获取写锁。
- 写离：当前写-1。如果存在等待写，当前写+1,等待写-1，释放写锁，继续给写。否则如果等待读存在，遍历释放所有读锁。

写锁释放一次，在读离、写离的时候判断等待写。读锁释放多次，在写离的时候。

读进、写进都得判断空状态，否则等待锁释放。

读进的时候只会被写给等待.例子: [rlock](./rlock.py) 、 [synch](./synch.py)

- [Python线程专题5:信号量与有边界的信号量](https://segmentfault.com/a/1190000016330131)
- [使用python实现可重入的公平读写锁](http://www.py3study.com/Article/details/id/6317.html)
- [并发编程的锁机制：synchronized和lock](https://juejin.cn/post/6844903542440869896)
