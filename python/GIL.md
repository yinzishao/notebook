# Python的GIL

> - [Python的GIL](http://cenalulu.github.io/python/gil-in-python/)

首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。

Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL


> In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is **necessary mainly because CPython’s memory management is not thread-safe**. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)

好吧，是不是看上去很糟糕？**一个防止多线程并发执行机器码的一个Mutex**，乍一看就是个BUG般存在的全局锁嘛！


Python当然也逃不开，为了利用多核，Python开始支持多线程。而**解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁**。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的**内存锁和同步操作**）。

> 指的是内部对象，内存管理的线程安全。

> 慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。

可以看到python在多线程的情况下居然比单线程整整慢了45%。按照之前的分析，即使是有GIL全局锁的存在，串行化的多线程也应该和单线程有一样的效率才对。那么怎么会有这么糟糕的结果呢？


## 缺陷

### 基于pcode数量的调度方式
按照Python社区的想法，操作系统本身的**线程调度**已经非常成熟稳定了，没有必要自己搞一套。所以Python的线程就是C语言的一个**pthread**，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会**计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度**（当然是否真正进行上下文切换由操作系统自主决定）。

```python

while True:
    acquire GIL
    for i in 1000:
        do something
    release GIL
    /* Give Operating System a chance to do thread scheduling */
```

这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，**从release GIL到acquire GIL之间几乎是没有间隙的**。所以当其他在其他核心上的线程被唤醒时，大部分情况下**主线程已经又再一次获取到GIL了**。这个时候**被唤醒执行的线程只能白白的浪费CPU时间**，看着另一个线程拿着GIL欢快的执行着。然后**达到切换时间后进入待调度状态**，再被唤醒，再等待，以此往复恶性循环。

> **子线程唤醒的间隙，主线程再次获得锁，导致子线程一直被唤醒，等待，却不能获得GIL锁，浪费CPU时间**。不停唤醒

PS：当然这种实现方式是原始而丑陋的，Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如**先尝试持有GIL在做线程上下文切换**，**在IO等待时释放GIL等尝试**。但是无法改变的是GIL的存在使得操作系统线程调度的这个本来就昂贵的操作变得更**奢侈**了。

> 在IO等待时释放GIL等尝试、先尝试持有GIL在做线程上下文切换

## 总结

简单的总结下就是：**Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降**。

## 如何避免受到GIL的影响

### 用multiprocessing替代Thread

multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。

它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，**对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了**。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个**Queue**，put再get或者用**share memory**的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。

> 进程间的通讯导致编码成本过高的问题

当然Python社区也在非常努力的不断改进GIL，甚至是尝试去除GIL。并在各个小版本中有了不少的进步。有兴趣的读者可以扩展阅读这个Slide 另一个改进Reworking the GIL:

- 将切换颗粒度从基于opcode计数改成**基于时间片计数**
- 避免最近一次释放GIL锁的线程再次被**立即调度**
- 新增**线程优先级**功能（高优先级线程可以迫使其他线程释放所持有的GIL锁）

---
# 谈谈python的GIL、多线程、多进程
> - [谈谈python的GIL、多线程、多进程](https://zhuanlan.zhihu.com/p/20953544)

在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。

而在python3.x中，**GIL不使用ticks计数，改为使用计时器**（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序更加友好，但依然没有解决GIL导致的**同一时间只能执行一个线程的问题**，所以效率依然不尽如人意。

1. CPU密集型代码(各种循环处理、计数等等)，在这种情况下，ticks计数很快就会达到阈值，然后**触发GIL的释放与再竞争**（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。

2. IO密集型代码(文件处理、网络爬虫等)，**多线程能够有效提升效率**(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。


---
# 深入理解Python中的GIL
> - [深入理解Python中的GIL](https://zhuanlan.zhihu.com/p/75780308)

很明显，在一个现代多核心的处理器上，上面的模型就有很大优化空间了，原来只能等待的线程任务，现在可以在其它空闲的核心上调度并发执行。由于古老GIL机制，如果线程2需要在CPU 2 上执行，它需要先等待在CPU 1 上执行的线程1释放GIL（记住：GIL是全局的）。如果线程1是因为 i/o 阻塞让出的GIL，那么线程2必定拿到Gil。但**如果线程1是因为timer ticks计数满100让出GIL，那么这个时候线程1和线程2公平竞争**。但要命的是，在Python 2.x, **线程1不会动态的调整自身的优先级**，所以很大概率下次被选中执行的还是线程1，在很多个这样的选举周期内，**线程2只能安静的看着线程1拿着GIL在CPU 1上欢快的执行**。

在稍微极端一点的情况下，比如线程1使用了while True在CPU 1 上执行，那就真是“一核有难，八核围观”

上面这段代码，在Python3上运行，不管是并发执行还是顺序执行，运行时间都差不多，这充分说明了GIL确实会在这种情况下对多线程程序的运行效率产生影响。如果是在Python2上运行，则差距更明显。

## GIL是否意味着线程安全

有GIL并不意味着python一定是线程安全的，那什么时候安全，什么时候不安全，我们必须搞清楚。之前我们已经说过，一个线程有两种情况下会释放全局解释器锁，**一种情况是在该线程进入IO操作之前，会主动释放GIL**，另一种情况是**解释器不间断运行了1000字节码（Py2）或运行15毫秒（Py3）**后，该线程也会放弃GIL。既然一个线程可能随时会失去GIL，那么这就一定会涉及到线程安全的问题。GIL虽然从设计的出发点就是考虑到线程安全，但这种**线程安全是粗粒度的线程安全，即不需要程序员自己对线程进行加锁处理**（同理，所谓细粒度就是指程序员需要自行加、解锁来保证线程安全，典型代表是 Java , 而 CPthon 中是粗粒度的锁，即语言层面本身维护着一个全局的锁机制,用来保证线程安全）。那么什么时候需要加锁，什么时候不需要加锁，这个需要具体情况具体分析。下面我们就来针对每种可能的情况进行分析和总结。

首先来看第一种线程释放GIL的情况。假设现在线程A因为进入IO操作而主动释放了GIL，那么在这种情况下，**由于线程A的IO操作等待时间不确定，那么等待的线程B一定会得到GIL锁**，这种比较“礼貌的”情况我们一般称为“**协同式多任务处理**”，相当于大家按照协商好的规则来，线程是安全的，不需要额外加锁。

接下来，我们来看另外一种情况，即线程A是因为**解释器不间断执行了1000字节码的指令或不间断运行了15毫秒而放弃了GIL**，那么此时实际上线程A和线程B将同时竞争GIL锁。在同时竞争的情况下，实际上谁会竞争成功是不确定的一个结果，所以一般被称为“**抢占式多任务处理**”，这种情况下当然就看谁抢得厉害了。当然，在python3上由于对GIL做了优化，并且**会动态调整线程的优先级**，所以线程B的优先级会比较高，但仍然无法肯定线程B就一定会拿到GIL。那么在这种情况下，线程可能就会**出现不安全的状态**。针对这种纯计算的操作，我们用一段代码来演示下这种线程不安全的状态

> 协同式多任务处理、抢占式多任务处理

---
# 原子性操作

> - [通俗易懂：说说 Python 里的线程安全、原子操作](https://juejin.cn/post/6844904159120998408)

原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程。

在 Python 的官方文档上，列出了一些常见原子操作
```python
L.append(x)
L1.extend(L2)
x = L[i]
x = L.pop()
L1[i:j] = L2
L.sort()
x = y
x.field = y
D[x] = y
D1.update(D2)
D.keys()
```

而下面这些就不是原子操作
```python
i = i+1
L.append(L[-1])
L[i] = L[j]
D[x] = D[x] + 1
```
像上面的我使用自增操作 number += 1，其实等价于 number = number + 1，可以看到**这种可以拆分成多个步骤（先读取相加再赋值），并不属于原子操作**。

当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试**通过 dis 模块里的 dis 函数来查看**

**每一条字节码指令都是一个整体，无法分割**，他实现的效果也就是我们所说的原子操作。

当一行代码被**分成多条字节码指令的时候**，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确。

上面这么多字节码指令，写操作都只有一个（POP_TOP），因此字典的 update 方法是原子操作。

Python 的 threading 模块里的消息通信机制主要有如下三种：

- Event
- Condition
- Queue

使用最多的是 Queue，而我们都知道它是线程安全的。当我们对它进行写入和提取的操作不会被中断而导致错误，这也是我们在使用队列时，不需要额外加锁的原因。

他是如何做到的呢？

其根本原因就是 Queue 实现了**锁原语**，因此他能像第三节那样实现人工原子操作。

原语指由若干个机器指令构成的完成某种特定功能的一段程序，**具有不可分割性**；即原语的执行必须是连续的，在执行过程中不允许被中断。

> 更深入则需要去了解字节码了

---
# Python有GIL为什么还需要线程同步？

GIL 的作用是：对于一个解释器，只能有一个thread在执行bytecode。所以每时每刻只有一条bytecode在被执行一个thread。GIL保证了bytecode 这层面上是thread safe的。但是如果你有个操作比如 x += 1，这个操作需要多个bytecodes操作，在执行这个操作的多条bytecodes期间的时候可能中途就换thread了，这样就出现了data races的情况了。

- <https://www.zhihu.com/question/23030421/answer/36220770>

GIL 的作用是：对于一个解释器，只能有一个thread在执行bytecode。所以每时每刻只有一条bytecode在被执行一个thread。GIL保证了bytecode 这层面上是thread safe的。但是如果你有个操作比如 x += 1，这个操作需要多个bytecodes操作，在执行这个操作的多条bytecodes期间的时候可能中途就换thread了，这样就出现了data races的情况了。

- <https://www.zhihu.com/question/23030421/answer/36220770>

GIL是对整个python解释器，对python提供的C API的访问都是互斥的，看作是python内核级的互斥机制。内核级通过GIL实现内核的共享资源的保护。用户级的互斥保护用户程序中的共享资源。

- 《Python源码剖析》
