"""
dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。

比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。

如果你把这第 i 个物品装入了背包，那么 dp[i][w] 应该等于 dp[i-1][w - wt[i-1]] + val[i-1]。

首先，由于 i 是从 1 开始的，所以 val 和 wt 的索引是 i-1 时表示第 i 个物品的价值和重量。
"""


def knapsack(w, n, wt, val):
    """从左往右，从上往下方向进行计算"""
    dp = [[0 for _ in range(0, w + 1)] for _ in range(0, n + 1)]
    for i in range(1, n + 1):
        # 当前背包的容量遍历
        for j in range(1, w + 1):
            # 当前的物品的重量
            c_w = wt[i - 1]
            # 当前的物品的价值
            c_v = val[i - 1]
            # 当前背包容量不足当前物品的容量
            if j - c_w < 0:
                # 这种情况下只能选择不装入背包
                dp[i][j] = dp[i - 1][w]
            else:
                dp[i][j] = max(
                    # 装入，则价值等于上一个没装入减去当前物品重量的最优值，加上当前价值。
                    dp[i - 1][j - c_w] + c_v,
                    # 没装入，价值等于上一个没装入价值的结果
                    dp[i - 1][j]
                )

    for i in dp:
        print(i)
    return dp[n][w]


w = 6
n = 3
wt = [2, 1, 3]
val = [4, 2, 3]
print(knapsack(w, n, wt, val))
