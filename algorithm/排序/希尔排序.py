"""
思路

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量

优劣

不需要大量的辅助空间，和归并排序一样容易实现。希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间的时间复杂度为O(n^3/2)，希尔排序时间复杂度的下界是n*log2n。

希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n^2)复杂度的算法快得多。并且希尔排序非常容易实现，算法代码短而简单。

此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法.

本质上讲，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多。 原因是，当n值很大时数据项每一趟排序需要移动的个数很少，但数据项的距离很长。当n值减小时每一趟需要移动的数据增多，此时已经接近于它们排序后的最终位置。

 正是这两种情况的结合才使希尔排序效率比插入排序高很多。Shell算法的性能与所选取的分组长度序列有很大关系。只对特定的待排序记录序列，可以准确地估算关键词的比较次数和对象移动次数。想要弄清关键词比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，今仍然是数学难题。
"""
import random


def shell_sort(n):
    print(f"input {input} ,")
    l = len(n)
    step = int(l / 2)
    while step > 0:
        for i in range(step, l):
            # 插入排序
            temp = n[i]
            j = i - step
            while j >= 0 and n[j] > temp:
                n[j + step] = n[j]
                j -= step
            n[j + step] = temp
        step = int(step / 2)

    print(f"result {n}")
    return n


input = [random.randint(1, 20) for _ in range(0, 10)]
print(f"input {input} ,result {shell_sort(input)}")

"""
每个step里面是冒泡排序的话，会有什么好处呢？也可以减少移动的距离。但是根本区别还是冒泡排序与插入排序的区别。
分组应该都能优化移动的次数？
"""
