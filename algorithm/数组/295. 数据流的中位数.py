"""
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-median-from-data-stream
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

"""


"""

#### 方法二： 插入排序

保持输入容器始终排序

**算法：**
哪种算法允许将一个数字添加到已排序的数字列表中，但仍保持整个列表的排序状态？插入排序！

我们假设当前列表已经排序。当一个新的数字出现时，我们必须将它添加到列表中，同时保持列表的排序性质。这可以通过使用二分搜索找到插入传入号码的正确位置来轻松实现。
（记住，列表总是排序的）。一旦找到位置，我们需要将所有较高的元素移动一个空间，以便为传入的数字腾出空间。

当插入查询的数量较少或者中间查找查询的数量大致相同。 此方法会很好地工作。

**复杂度分析**

*   时间复杂度： O ( n ) + O ( log ⁡ n ) ≈ O ( n ) O(n) + O(\\log n) \\approx O(n) O(n)+O(logn)≈O(n).

1.  二分搜索需要花费 O ( log ⁡ n ) O(\\log n) O(logn) 时间才能找到正确的插入位置。
2.  插入可能需要花费 O ( n ) O(n) O(n) 的时间，因为必须在容器中移动元素为新元素腾出空间。

*   空间复杂度： O ( n ) O(n) O(n) 线性空间，用于在容器中保存输入。


#### 方法三：两个堆
这给了我们一个很好的特性，即当堆完全平衡时，中间值可以从两个堆的顶部派生。否则，最大堆 `lo` 的顶部保留合法的中间值。

*   添加一个数 `num`：

1.  将 `num` 添加到最大堆 `lo`。因为 `lo` 收到了一个新元素，所以我们必须为 `hi` 做一个平衡步骤。因此，从 `lo` 中移除最大的元素并将其提供给 `hi`。
2.  在上一个操作之后，最小堆 `hi` 可能会比最大堆 `lo` 保留更多的元素。我们通过从 `hi` 中去掉最小的元素并将其提供给 `lo` 来解决这个问题。

**复杂度分析**

*   时间复杂度： O ( 5 ⋅ log ⁡ n ) + O ( 1 ) ≈ O ( log ⁡ n ) O(5 \\cdot \\log n) + O(1) \\approx O(\\log n) O(5⋅logn)+O(1)≈O(logn).。

1.  最坏情况下，从顶部有三个堆插入和两个堆删除。每一个都需要花费 O ( log ⁡ n ) O(\\log n) O(logn) 时间。
2.  找到平均值需要持续的 O ( 1 ) O(1) O(1) 时间，因为可以直接访问堆的顶部。

*   空间复杂度： O ( n ) O(n) O(n) 用于在容器中保存输入的线性空间
"""
