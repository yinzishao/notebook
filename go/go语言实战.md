## 第18页
goroutine 使用的内存比线程更少， Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处理器绑定到一个操作系统线程上（见图 1-2）。这让用户的应用程序执行效率更高，而开发工作量显著减少。

## 第19页
通道是一种数据结构，可以让 goroutine 之间进行安全的数据通信。通道可以帮用户避免其他语言里常见的共享内存访问的问题。

其他语言用复杂的锁规则来防止对同一个变量的不同步修改。

## 第20页
Go 开发者使用组合（ composition）设计模式，只需简单地将一个类型嵌入到另一个类型，就能复用所有的功能。其和继承绑在一起使用

常复杂
由其他更微小的类型组合而成，避免了传统的基于继承的模型。
对行为进行建模，而不是对类型进行建模
器会判断一个类型的实例是否符合正在使用的接口
传统语言使用继承来扩展结构
然后把这些小类型组合成更大的类型

## 第21页
作鸭子类型
如果一个类型实现了一个接口的所有方法，那么这个类型的实例就可以存储在这个接口类型的实例中，不需要额外声明。
要求用户的类必须满足 User 接口里的所有约束，并且显式声明这个类实现了这个接口。
你只需要实现一个 Read 方法
Go 语言的接口更小，只倾向于定义一个单一的动作。实际使用中，这更有利于使用组合来复用代码

## 第22页
要先分配这段内存，而且使用完毕后要将其释放掉。哪怕只做错了一件事，都可能导致程序崩溃或者内存泄漏
Go 语言把无趣的内存管理交给专业的编译器去做，而让程序员专注于更 有趣的事情。

## 第26页
main 函数保存在名为 main 的包里。如果 main 函数不在 main 包里，构建工具就不会生成可执行的文件
每个代码文件都属于一个包，：一个包定义一组编译过的代码，包的名字类似命名空间，可以用来间接访问包内声明的标识符。这个特性可以把不同包中定义的同名标识符区别开

## 第27页
为了让 Go 语言对包做初始化操作，但是并不使用包里的标识符
不允许声明导入某个包却不使用
程序中每个代码文件里的 init 函数都会在 main 函数执行前调用。

## 第28页
会到 GOROOT 和 GOPATH 环境变量

## 第29页
这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其他包中的代码直接访问。
所有变量都被初始化为其零值

## 第31页
切片是一种实现了一个动态数组的引用类型。

## 第32页
编译器使用函数返回值的类型来确定每个变量的类型
据经验，如果需要声明初始值为零值的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回值创建变量，应该使用简化变量声明运算符
也是引用类型

## 第34页
指针变量可以方便地在函数之间共享数据。使用指针变量可以让函数访问并修改一个变量的状态，而这个变量可以在其他函数甚至是其他 goroutine 的作用域里声明。
**所有的变量都以值的方式传递**

## 第35页
因为有了闭包，函数可以直接访问到那些没有作为参数传入的变量。匿名函数并没有拿到这些变量的副本，而是直接访问外层函数作用域中声明的这些变量
本身。因为 matcher 和 feed 变量每次调用时值不相同，所以并没有使用闭包的方式访问这两个变量，
如果我们使用闭包访问这些变量，随着外层函数里变量值的改变，内层的匿名函数也会感知到这些改变。

## 第36页
而之前的代码保证了所有 results 通道里的数据被处理之前，Display 函数不会返回

## 第37页
每个字段的声明最后 ` 引号里的部分被称作标记（ tag）。这个标记里描述了 JSON 解码的元数据，
用于创建 Feed 类型值的切片。每个标记将结构类型里字段对应到 JSON 文档里指定名字的字段。

## 第38页
使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。关键字 defer 可以缩短打开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。

## 第40页
**如果接口类型只包含一个方法，那么这个类型的名字以 er 结尾。**

## 第41页
**空结构在创建实例时，不会分配任何内存**.这种结构很适合创建没有任何状态的类型。
如果声明函数的时候带有接收者，则意味着声明了一个方法。
这类型的值或者指向这个类型值的指针会正确地引用或者解引用对应的值

## 第42页


所以，一个最佳实践是，**将方法的接收者声明为指针**。

与直接通过值或者指针调用方法不同，如果通过**接口类型的值调用方法**，规则有很大不同

**使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时候被调用。
使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用**

var matcher Matcher = &dm
## 第43页
了 Matcher 接口的值或者指针能被接受。

## 第44页
一旦 search.go 代码文件第 51 行关闭了通道， for range 循环就会终止， Display 函数也会返回

## 第45页
一旦编译器发现 init 函数，它就会给这个函数优先执行的权限，保证其在 main 函数之前被调用

## 第51页
包名应该与代码文件所在的文件夹同名指针可以在函数间或者 goroutine 间共享数据

## 第53页
应该使用简洁、清晰且全小写的名字，
并不需要所有包的名字都与别的包不同，
使用全路径的，
都必须有一个名叫 main 的包。
main()函数是程序的入口，

## 第54页
标准库中的包会在安装 Go 的位置找到。在 GOPATH 环境变量指定的目录里查找

## 第55页
并把包的源代码保存在 GOPATH 指向的路径里与 URL 匹配的目录里。

## 第68页
数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型为其占用的内存是连续分配的。由于内存连续， CPU能把正在使用的数据缓存更久的时间。而且内存连续很容易计算索引，可以快速迭代数组里的所有元素。数个元素类型相同，又是连续分配，

## 第69页
一旦声明，数组里存储的数据类型和数组长度就都不能改变了。如果需要存储更多的元素，
就需要先创建一个更长的数组，再把原来数组里的值复制到新数组里。
用...替代数组的长度， Go 语言会根据初始化时数组元素的数量来确定该数组的长度

## 第70页
= [...]int{10, 20, 30, 40, 50}
指定特定元素的值
= [5]int{1: 10, 2: 20}
因为内存布局是连续的，数组是效率很高
= [5]int{10, 20, 30, 40, 50}
声明一个所有元素都是指针的数组。使用*运算符就可以访问元素指针所指向的值
## 第71页
= [5]*int{0: new(int), 1: new(int)}
= [5]string{"Red", "Blue", "Green", "Yellow", "Pink"}
数组长度和每个元素的类型才能互相赋值
复制数组指针，只会复制指针的值，而不会复制指针所指向的值?

## 第74页
在函数间传递数组是一个开销很大的操作。**在函数之间传递变量时，总是以值的方式传递的**

## 第75页
复制到刚分配的内存里8 字节的数据
因为现在传递的是指针，所以如果改变指针指向的值，会改变共享的内存
切片是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小
因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处
这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。

## 第76页
/ 其长度为 3 个元素，容量为 5 个元素
= make([]int, 3, 5)
是初始化后并不能访问所有的数组元素。
基于这个切片创建新的切片，新切片会和原有切片共享底层数组，也能通过后期操作来访问多余容量的元素。

## 第77页
通过切片字面量来声明切片
使用索引声明切片
如果在[]运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值的时候，才会创建切片

## 第78页
nil 切片是很常见的创建切片的方法。
在需要描述一个不存在的切片时， nil 切片会很好用。例个空切片，
片在底层数组包含 0 个元素，也没有分配任何存储空间。
对其调用内置函数 append、 len 和 cap 的效果都是一样的。

## 第79页
有了两个切片，它们共享同一段底层数组，但通过不同的切片会看到底层数组的不同部分们共享

## 第80页
计算出任意切片的长度和容量对底层数组容量是 k 的切片 slice[i:j]来说
长度: j - i
容量: k - i

如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到，片修改了该底层数组的共享部分，另一个切片也能感知到
同时也修改了
切片只能访问到其长度内的元素。试图访问超出其长度的元素将会导致语言运行时异常，

## 第81页
切片有额外的容量是很好。但是如果不能把这些容量合并到切片的长度里，这些容量就没有 用处。好在可以用 Go 语言的内置函数 append 来做这种合并很容易

append 调用返回时，会返回一个包含修改结果的新切片会返回一个包含修改结果的新切片
总是会增加新切片的长度，而容量有可能会改变，也可能不会改变，这取决于被操作的切片的可用容量。

## 第82页
由于和原始的 slice 共享同一个底层数组， slice 中索引为 3 的元素的值也被改动了。
如果切片的底层数组没有足够的可用容量， append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值
函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25%的容量

！：第三个索引可以用来控制新切片的容量。其目的并不是要增加容量，而是要限制容量。可以看到，允许限制新切片的容量为底层数组提供了一定的保护，可以更好地控制追加操作。

## 第84页
= source[2:3:4]
设置的容量比可用的容量还大，就会得到一个语言运行时错误，
首先使用可用容量切片间正在共享同一个底层数组对切片内容的修改会影响多个切片，却很难找到问题的原因。
如果**在创建切片时设置切片的容量和长度一样**，就可以强制让新切片的第一个 append 操作
**创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改**
由于剩余的所有容量都属于 slice，向 slice 追加 Kiwi 会改变原有底层数组索引为 3 的元素的值 Banana
会创建一个新的底层数组拥有了自己的底层数组，

## 第87页
是该位置对应元素值的一份副本（
range 创建了每个元素的副本，而不是直接返回对该元素的引用
该值变量的地址作为指向每个元素的指针，
> 固定rang变量的地址

## 第88页
根据切片依次赋值的新变量，所以 value 的地址总是相同的切片变量和索引值

## 第89页
`= [][]int{{10}, {100, 200}}`

## 第90页
先增长切片，再将新的整型切片赋值
给外层切片的第一个元素
像这样传递数据结构也会很复杂。
一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量

## 第91页
字段分别需要 8 字节
对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组
在函数间传递 24 字节的数据会非常快速、简单。这也是切片效率高的地方。
不需要传递指针和处理复杂的语法，只需要复制切片，按想要的方式修改数据，然后传递回一份新的切片副本。
新的切片副本。

## 第92页
没有办法预测键值对被返回的顺序。即
映射使用两个数据结构来存储数据。
第一个数据结构是一个数组，内部存储的是用于选择桶的散列键的高八位值。这个数组用于区分每个键值对要存在哪个桶里。
第二个数据结构是一个字节数组，用于存储键值对。

## 第93页
映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值可以使用==运算符做比较。
用字符串切片作为映射的键
= map[[]string]int{}

## 第94页
使用字符串切片作为值
map[int][]string{}
一个空映射，
个未初始化的映射为 nil 的映射（
不能用于存储键值对，
否完成了某个操作或者是否在映射里缓存了特定数据

## 第95页
是不是零值来确定键是否存在，
，通过键来索引映射时，即便这个键不存在也总会返回一个值。在这种情况下，
返回的是该值对应的类型的零值

## 第96页
在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对
这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改，

> Q:不是说都是值传递么？A:本质上是说指针的值传递。见下

## 第97页
内置函数 make 可以创建切片和映射，并指定原始的长度和容量。
将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。

## 第99页
声明一个变量，并初始化。短变量声明操作符会使用右侧给出的类型信息作为声明变量的类型并初始化所有字段

## 第100页
不使用字段名，创建结构类型的值值的顺序很重要，必须要和结构声明中字段的顺序一致。当声新结构类型。

## 第101页
并不认为 Duration 和 int64 是同一种类型。这两个类型是完全不同的有区别的类型。
int64 类型是基础类型， Duration 类型依然是一个独立的类型。两种不同类型的值即便互相兼容，也不能互相赋值。编译器不会对不同类型的值做隐式转换

## 第103页
关键字 func 和函数名之间的参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法
notify 方法的接收者被声明为 user 类型的值。如果使用值接收者声明方法，调用时会使用这个值的一个副本来执行。
user 类型的值可以用来调用使用值接收者声明的方法

## 第104页
使用 bill 的值作为接收者进行调用，方法 notify会接收到 bill 的值的一个副本
值接受者也可以使用这个指针变量来调用 notify 方法。为了支持这种方法调用， Go 语言调整了指针的值，来符合方法接收者的定义。
隐式转换：(*lisa).notify()
指针被解引用为值，这样就符合了值接收者的要求。再强调一次， notify 操作的是一个副本，只不过这次操作的是从 lisa 指针指向的值的副本
指针接收法会共享调用方法时接收者所指向的值，

## 第105页
**总结一下，值接收者使用：值的副本来调用方法，而指针接受者使用实际值来调用方法。**

先引用 bill 值得到一个指针，这样这个指针就能够匹配方法的接收者类型，再进行调用。
Go语言既允许使用值，也允许使用指针来调用方法，

不是按值做传递，还是按指针做传递。保持传递的一致性很重要。

## 第106页
是数值类型、字符串类型和布尔类型
因此，当对这些值进行增加或者删除的时候，会创建一个新值
当把这些类型的值传递给方法或者函数时，**应该传递一个对应值的副本**
所以在函数或方法内外传递时，要传递字符串的一份副本。
这里的参数没有使用指针来共享参数的值或者返回值。调用者传入了一个 uint8 值的副本，并接受一个返回值 true 或者 false。
引用类型
Go 语言里的引用类型有如下几个：**切片、映射、通道、接口和函数类型**。

## 第107页
字符串也是一种引用类型。

每个引用类型创建的标头值是包含一个指向底层数据结构的指针。
每个引用类型还包含一组独特的字段，用于管理底层数据结构。
因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。
标头值里包含一个指针，因此通过**复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构**。
最后要说的是，引用类型的值在其他方面像原始的数据类型的值一样对待。
> ?:TODO


## 第108页
数没有使用指针来共享 Time 值

## 第109页
这个方法使用值接收者，并返回了一个新的 Time 值。该方法操作的是调用者
传入的 Time 值的副本，并且给调用者返回了一个方法内的 Time 值的副本。
至于是使用返回的值替换原来的 Time 值，还是创建一个新的 Time 变量来保存结果，是由调用者决定的事情
当需要修改值本身时，在程序中其他地方，需要使用指针来共享这个值。让

20 // file 是*File 的实际表示
21 // 额外的一层结构保证没有哪个 os 的客户端
22 // 能够覆盖这些数据。如果覆盖这些数据，
23 // 可能在变量终结时关闭错误的文件描述符
以 File 类型的实现使用了一个嵌入的指针，指向一个未公开的类型
这层额外的内嵌类型阻止了复制

## 第113页
如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。

接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。
iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。
第二个字是一个指向所存储值的指针。将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。

## 第115页
user 类型并没有实现 notifier
（notify 方法使用指针接收者声明）却无法通过编译。

这个方法是使用 user 类型的指针接收者实现的。

## 第116页
方法集定义了一组关联到给定类型的值或者指针的方法。
定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。
T 类型的值的方法集只包含值接收者声明的方法。而指向 T 类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法。

## 第117页
这个规则说，如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。
如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。
用指针接收者实现了接口，但是试图将 user 类型的值传给如果传递的是 user 值的地址，整个程序就能通过编译，并且能够工作了
事实上，编译器并不是总能自动获得一个值的地址

## 第118页
因为不是总能获取一个值的地址，所以值的方法集只包括了使用值接收者实现的方法。

## 第120页
既然任意一个实体类型都能实现该接口，那么这个函数可以针对任意实体类型的值来执行 notifier 方法。因此，这个函数就能提供多态的行为
嵌入类
是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型

## 第122页
要嵌入一个类型，只需要声明这个类型的名字就可以了。
user 是外部类型 admin 的内部类型
我们可以直接访问内部类型的方法
/ 内部类型的方法也被提升到外部类型

## 第125页
由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。

## 第128页
。这表明，如果外部类型实现了 notify 方法，内部类型的实现就不会被提升。
不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。
需要一种方法，将这些标识符声明为包外不可见，这时需要将这些标识符声明为未公开的

## 第129页
当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。
如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见。

## 第130页
由于 counters 包里的 alertCounter 类型是使用小写字母声明的，所以这个标识符是未
公开的，无法被 listing64.go 的代码访问。如果我们把这个类型改为用大写字母开头，那么就不会产生编译器错误。

## 第131页
将工厂函数命名为 New 是 Go 语言的一个习惯。这个 New 函数做了些有意思的事情：它创建了一个未公开的类型的值，并将这个值返回给

## 第132页
main 函数能够接受这个值并创建一个未公开的类型的变量
第一，公开或者未公开的标识符，不是一个值。
第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。
永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。

## 第133页
名为 email 的未公开的字段

## 第134页
因为 email 这个标识符未公开，所以它不能在 entities 包外被访问
展示公开的结构类型中如何访问

## 第135页
设置未公开的内部类型的
19 // 公开字段的值
## 第136页
由于内部类型 user 是未公开的，这段代码无法直接通过结构字面量的方式初始化该内部类型。
不过，即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。
既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问

## 第137页
。 Go 语言
运行时的调度器是一个复杂的软件，能管理被创建的所有 goroutine 并为其分配执行时间。
这个调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行goroutine。
调度器在任何给定的时间，都会全面控制哪个 goroutine 要在哪个逻辑处理器上运行。

通信顺序进程
而不是对数据进行加锁来实现同步访问

## goroutine
## 第138页 [](#bookmark)
内存地址空间、文件和设备的句柄以及线程
每个进程至少包含一个线程，每个进程的初始线程被称作主线程操作系统
将线程调度到某个处理器上运行，这个处理器并不一定是进程所在的处理器
逻辑处理器上调度goroutine来运行

如果创建一个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。
之后，调度器就将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。
本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。

有时，正在运行的 goroutine 需要执行一个阻塞的系统调用，如打开一个文件。当这类调用
发生时，线程和 goroutine 会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。
与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其
绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个 goroutine 来运行。一旦
被阻塞的系统调用执行完成并返回，对应的 goroutine 会放回到本地运行队列，而之前的线程会
保存好，以便之后可以继续使用。

如果一个 goroutine 需要做一个网络 I/O 调用，流程上会有些不一样。在这种情况下，goroutine
会和逻辑处理器分离，并移到集成了网络轮询器的运行时。一旦该轮询器指示某个网络读或者写
操作已经就绪，对应的 goroutine 就会重新分配到逻辑处理器上来完成操作。调度器对可以创建
的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建 10 000 个线程。这个
限制值可以通过调用 runtime/debug 包的 SetMaxThreads 方法来更改。如果程序试图使用
更多的线程，就会崩溃。

## 第142页
基于调度器的内部算法，一个正运行的 goroutine 在工作结束前，可以被停止并重新调度。

## 第147页
如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时
读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（

## 第148页
每个 goroutine 创造了一个 counter 变量的副本，之后就切换到另一个 goroutine。当这个 goroutine
再次运行的时候， counter 变量的值已经改变了，但是 goroutine 并没有更新自己的那个副本的
值，而是继续使用这个副本的值，用这个值递增，并存回 counter 变量，结果覆盖了另一个
goroutine 完成的工作

## 第149页
变量的副本存入一个叫作

## 第156页
无缓冲的通道（ unbuffered channel） 是指在接收前没有能力保存任何值的通道。这
如果两个 goroutine没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。

## 第161页
只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲
区容纳被发送的值时，发送动作才会阻塞。

## 第171页
default 分支会将接收 interrupt 通道的阻塞调用转变为非阻塞的

## 第172页
创建 goroutine 后， Start 进入一个 select 语句，阻塞等待两个事件中的任意一个

## 第173页
使用有缓冲的通道实现资源池，来管理可以在任意数量的goroutine之间共享及独立使用的资源


# 小结

讲得还是清晰详细．语言中的一些特性、注意事项都有说到。并且能赋予具体的例子和详细的说明。

第四章：数组、切片和映射。
第五章：类型系统（内置类型、引用类型、结构类型）、接口、嵌入类型
详细说明了用法和底层结构，值得细读。

第6章：并发。说明goroutine的原理和使用细节。并介绍通道和锁相关的。
第7章：并发模式。用了几个具体的例子来说明并发模式。（任务管理、并发池管理、无缓冲通道）
