## 1.3混乱的代价

只要你干过两三年编程，就有可能曾被某人的糟糕的代码绊倒过。如果你编程不止两三年，也有可能被这种代码拖过后腿。进度延缓的程度会很严重。有些团队在项目初期进展迅速，但有那么一两年的时间却慢如蜗行。对代码的每次修改都影响到其他两三处代码。修改无小事。每次添加或修改代码，都得对那堆扭纹柴了然于心，这样才能往上扔更多的扭纹柴。这团乱麻越来越大，再也无法理清，最后束手无策。

随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降时，管理层就只有一作事可做了∶增加更多人手到项目中，期望提升生产力。可是新人并不熟悉系统的设计。

### 1.3.1 华丽新设计
最后，开发团队造反了，他们告诉管理层，再也无法在这令人生厌的代码基础上做开发。他们要求做全新的设计。管理层不愿意投入资源完全重启炉灶，但他们也不能否认生产力低得可怕。他们只好同意开发者的要求，授权去做一套看上去很美的华丽新设计。
于是就组建了一支新军。谁都想加入这个团队，因为它是张白纸。他们可以重新来过，搞出点真正漂亮的东西来。但只有最优秀、最聪明的家伙被选中。其余人等则继续维护现有系统。
现在有两支队伍在竞赛了。新团队必须搭建一套新系统，要能实现旧系统的所有功能。另外，还得跟上对旧系统的持续改动。在新系统功能足以抗衡旧系统之前，管理层不会替换掉旧系统。
竞赛可能会持续极长时间。我就见过延续了十年之久的。到了完成的时候，新团队的老成员早已不知去向，而现有成员则要求重新设计一套新系统，因为这套系统太烂了。
假使你经历过哪怕是一小段我谈到的这种事，那么你一定知道，花时间保持代码整洁不但有关效率，还有关生存。

### 1.3.2 态度
怎么会发生这种事?为什么好代码会这么快就变质成糟糕的代码?理由多得很。我们抱怨需求变化背离了初期设计。我们哀叹进度太紧张，没法干好活。我们把问题归咎于那些愚赛的经理、苛求的用户、没用的营销方式和那些电话消毒剂。不过，我们是自作自受²。我们太不专业了。

同理，程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。

> 遵从不了解混乱风险的经理的意愿，也是不专业的做法。


缺乏"代码感"的程序员，看混乱是混乱，无处着手。有"代码感"的程序员能从混乱中看出其他的可能与变化。"代码感"帮助程序员选出最好的方案，并指导程序员制订修改行动计划，按图索骥。简言之，编写整洁代码的程序员就像是艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统。

### 破窗理论

务实的Dave Thomas和Andy Hunt从另一角度阐述了这种情况。他们提到破窗理论'。窗户破损了的建筑让人觉得似乎无人照管。于是别人也再不关心。他们放任窗户继续破损。最终自己也参加破坏活动，在外墙上涂鸦，任垃圾堆积。一扇破损的窗户开辟了大厦走向倾颓的道路。

Bjame以"整洁的代码只做好一件事"结束论断。毋庸置疑，软件设计的许多原则最终都会归结为这句警语。有那么多人发表过类似的言论。精糕的代码想做太多事，它意图混乱、目的含混。整洁的代码力求集中。每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。

在以上诸项中，我最在意代码重复。如果同一段代码反复出现，就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么，然后再尽力更清晰地表达出来。

减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。


让营地比你来时更干净。

---

# 有意义的命名

## 2.2　名副其实
ProductInfo类、ProductData类，那它们的名称虽然不同，意思却无区别。Info和Data就像a、an和the一样是意义含混的废话。

如果缺少明确约定，变量 moneyAmount 就与money 没区别，customerInfo与customer 没区别，accountData与account 没区别，theMessage也与message 没区别。要区分名称，就要以读者能鉴别不同之处的方式来区分。

## 2.3　避免误导

## 2.4　做有意义的区分
数字系列命名

## 2.5　使用读得出来的名称

## 2.6　使用可搜索的名称
常量使用可搜索的名称。

窃以为单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应

## 2.7　避免使用编码
### 2.7.1　匈牙利语标记法
所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统让编码系统误导读者的可能性。

没有必要带类型，phoneString。

### 2.7.2　成员前缀
也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。

### 2.7.3　接口和实现
特例

## 2.8　避免思维映射
不应当让读者在脑中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。
> 使用专业的名称，避免i、j、k

## 2.9　 类名
类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。

## 2.10　方法名
方法名应当是动词或动词短语，如postPayment、deletePage或 save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准'加上get、set和 is前缀。

## 2.11　别扮可爱

## 2.12　每个概念对应一个词
给每个抽象概念选一个词，并且一以贯之。

## 2.13　别用双关语
## 2.14　使用解决方案领域名称
记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science，CS）术语、算法名、模式名、数学术语吧。依据问题所涉领域来命名可不算是聪明的做法，因为不该让协作者老是跑去问客户每个名称的含义，其实他们早该通过另一名称了解这个概念了。

## 2.15　使用源自所涉问题领域的名称

## 2.16　添加有意义的语境
很少有名称是能自我说明的——多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。

可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。

> 名称不能自我说明，最好是提供语境（同一个类、空间）。否则只能添加前缀了。

上列函数有点儿过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatistisMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。（如代码清单2-2所示。）

> 多些思考这部分的场景。很常见

## 2.17　不要添加没用的语境
只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。

对于Adrss类的实体来说，accountAdrss和customerAdrss都是不错的名称，不过用在类名上就不太好了。Adres是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddres、MAC和URI。这样的名称更为精确，而精确正是命名的要点。


# 第三章 函数

## 3.1　短小
if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，

## 3.2　只做一件事
所以，要判断函数是否不止做了一件事，还有一个方法，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现。

## 3.3　每个函数一个抽象层级
自顶向下读代码∶向下规则

我们想要让代码拥有自顶向下的阅读顺序。'我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。我把这叫做向下规则。

换一种说法。我们想要这样读程序∶程序就像是一系列TO起头的段落，每一段都描述当前抽象层级，并引用位于下一抽象层级的后续 TO起头段落。

> 这个很常见的错误

## 3.4　switch语句
我们总无法避开switch语句，不过还是能够确保每个switch都埋藏在较低的抽象层级，而且永远不重复。当然，我们利用多态来实现这一点。

## 3.5　使用描述性的名称
别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。使用某种命名约定，让函数名称中的多个单词容易阅读，然后使用这些单词给函数取个能说清其功用的名称。

命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。

## 3.6　函数参数
参数不易对付。它们带有太多概念性。所以我在代码范例中几乎不加参数。比如，以StingBufer为例，我们可能不把它作为实体变量，而是当作参数来传递，那样的话，读者每次看它都得翻译一遍。

标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。

如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。

从参数创建对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。当一组参数被共同传递，就像上例中的x和y那样，往往就是该有自己名称的某个概念的一部分。

给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如，write（name）就相当令人认同。不管这个"name"是什么，都要被"write"。更好的名称大概是writeField（name）），它告诉我们，"name"是一个"field"。


## 3.7　无副作用
副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。

时序性耦合令人迷惑，特别是当它躲在副作用后面时。如果一定要时序性耦合，就应该在函数名称中说明。在本例中，可以重命名函数为checkPaswordAndInitiaizeSession，虽然那还是违反了"只做一件事"的规则。

## 3.8　分隔指令与询问
函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态或是返回该对象的有关信息。两样都干常会导致混乱。

## 3.9　使用异常替代返回错误码

使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署²。

这样的类就是一块依赖磁铁（dependency magnet）;其他许多类都得导入和使用它。当Eror枚举修改时，所有这些其他的类都需要重新编译和部署。'这对Eror类造成了负面压力。程序员不愿增加新的错误代码，因为这样他们就得重新构建和部署所有东西。于是他们就复用旧的错误码，而不添加新的。

> 不是用错误码的常量进行表达，而是通过异常类进行表达。开放闭合原则

## 3.9.1　抽离Try/Catch代码块
Try/catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把 try和catch代码块的主体部分抽离出来，另外形成函数。

## 3.9.2　错误处理就是一件事
函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。这意味着（如上例所示）如果关键字 try在某个函数中存在，它就该是这个函数的第一个单词，而且在 catch/finally代码块后面也不该有其他内容。

## 3.9.3　Error.java依赖磁铁
使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署²。

> 不是用错误码的常量进行表达，而是通过异常类进行表达。开放闭合原则

## 3.10　别重复自己
## 3.11　结构化编程
有些程序员遵循 Edsger Dijksta的结构化编程规则。Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个returm语句，循环中不能有break或continue语句，而且永永远远不能有任何goto语句。
我们赞成结构化编程的目标和规范，但对于小函数，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。
所以，只要函数保持短小，偶尔出现的reum、break或continue语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto只在大函数中才有道理，所以应该尽量避免使用。

## 3.12　如何写出这样的函数
我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复的代码。不过我会配上一套单元测试，覆盖每行丑陋的代码。

然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。同时保持测试通过。

我并不从一开始就按照规则写函数。我想没人做得到。

# 对象和数据结构

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。

反过来讲也说得通∶过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。

在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候。这时，对象和面向对象就比较适合。另一方面，也会有想要添加新函数而不是数据类型的时候。在这种情况下，过程式代码和数据结构更合适。

### 得墨忒耳律
著名的得墨忒耳律（The Law of Demeter）'认为，模块不应了解它所操作对象的内部情形。如上节所见，对象隐藏数据，曝露操作。这意味着对象不应通过存取器曝露其内部结构，因为这样更像是曝露而非隐藏其内部结构。

更准确地说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法∶

- C
- 由f创建的对象;
- 作为参数传递给f的对象;·
- 由C的实体变量持有的对象。

方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。

这类代码常被称作火车失事，因为它看起来就像是一列火车。这类连串的调用通常被认为是肮脏的风格，应该避免【G36】。最好做类似如下的切分∶


### 数据传送对象

最为精练的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或DTO（Data Transfer Objects）。DTO是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类场景中。在应用程序代码里一系列将原始数据转换为数据库的翻译过程中，它们往往是排头兵。

我们不幸经常发现开发者往这类数据结构中塞进业务规则方法，把这类数据结构当成对象来用。这是不智的行为，因为它导致了数据结构和对象的混杂体。

当然，解决方案就是把Actve Record当做数据结构，并创建包含业务规则、隐藏内部数据（可能就是Active Record的实体）的独立对象。

> 分离数据基类与业务逻辑

### 10.2.3 保持内聚性就会得到许多短小的类

仅仅是将较大的函数切割为小函数，就将导致更多的类出现。想想看一个有许多变量的大函数。你想把该函数中某一小部分拆解成单独的函数。不过，你想要拆出来的代码使用了该函数中声明的4个变量。是否必须将这4个变量都作为参数传递到新函数中去呢?

完全没必要!只要将4个变量提升为类的实体变量，完全无需传递任何变量就能拆解代码了。应该很容易将函数拆分为小块。

可惜这也意味着类丧失了内聚性，因为堆积了越来越多只为允许少量函数共享而存在的实体变量。等一下!如果有些函数想要共享某些变量，为什么不让它们拥有自己的类呢?当类丧失了内聚性，就拆分它!

所以，将大函数拆为许多小函数，往往也是将类拆分为多个小类的时机。程序会更加有组织，也会拥有更为透明的结构。
