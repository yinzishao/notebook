
> 前几章主要通过CPU、内存、IO、网络层面介绍一些常识、基本的工具、命令的使用。一些统计信息的概念、常识介绍可以仔细研读。至于工具的使用可能需要在实战中在翻阅一些参数和输出的指标含义并熟练掌握。该书还是能提供相应的思路让我们去折腾。

# 系统CPU

这种不同进程间的切换称为上下文切换，因为当其发生时，CPU要保存旧进程的所有上下文信息，并取出新进程的所有上下文信息。上下文中包含了Linux跟踪新进程的大量信息，其中包括∶**进程正在执行的指令，分配给进程的内存，进程打开的文件等**。这些上下文切换涉及大量信息的移动，因此，上下文切换的开销可以是相当大的。尽量减少上下文切换的次数是个好主意.

要避免上下文切换，重要的一点是了解它们是如何发生的。首先，上下文切换可以是内核调度的结果。为了保证公平地给每个进程分配处理器时间，内核周期性地中断正在运行的进程，在适当的情况下，内核调度器会决定开始另一个进程，而不是让当前进程继续执行。每次这种**周期性中断或定时发生时**，你的系统都可能进行上下文切换。每秒定时中断的次数与架构和内核版本有关。一个检查中断频率的简单方法是用/proc/interrupts文件，它可以确定已知时长内发生的中断次数。

如果你的上下文切换明显多于定时器中断，那么这些切换极有可能是由I/O请求或其他长时间运行的系统调用（如休眠）造成的。当应用请求的操作不能立即完成时，内核启动该操作，保存请求进程，并尝试切换到另一个已就绪进程。这能让处理器尽量保持忙状态。

本章重点是关于CPU使用情况的系统级性能指标。这些指标主要展示的是操作系统和机器是如何运行的，而不是某个特定的应用程序。

本章展示了如何使用性能工具，如sar和vmstat，从正在运行的系统中抽取系统级性能信息。这些工具是诊断系统问题时的第一道防线。它们帮助确定系统表现如何，以及哪个子系统或应用程序可能压力较大。下一章将关注能分析系统整体内存使用情况的系统级性能工具。


# 系统内存

对IA32架构而言，页面大小为4KB。极少数情况下，这些页面大小的内存块会导致极高的跟踪开销，所以，内核用更大的块来操作内存，这些块被称为HugePage（大页面）。它们的容量为2048KB，而不是4KB，这大大降低了管理庞大内存的开销。某些应用，如Oracle，用这些大页面加载内存中的大量数据，同时又最小化Linux 内核的管理开销。如果HugePage不能完全被填满，就会浪费相当多的内存。一个半填充的普通页面浪费2KB内存，而一个半填充的HugePage 就会浪费1024KB 的内存。

Linux 内核可以分散收集这些物理页面，向应用程序呈现出一个精心设计的虚拟内存空间。

除了高速缓存，Linux还使用了额外的存储作为缓冲区。为了进一步优化应用程序，Linux为需要被写回硬盘的数据预留了存储空间。这些预留空间被称为缓冲区。如果应用程序要将数据写回硬盘，通常需要花费较长时间，Linux让应用程序立刻继续执行，但将文件数据保存到内存缓冲区。在之后的某个时刻，缓冲区被刷新到硬盘，而应用程序可以立即继续。

本章重点关注了系统级内存性能衡量指标。这些指标主要展示的是操作系统是如何使用内存而不是特定的应用程序。

本章说明了性能工具（如sar和vmstat）如何被用于从运行系统中提取其系统级内存统计信息。这些工具的输出表明了系统作为一个整体是怎样使用可用内存的。下一章将阐述研究单个进程的CPU 使用情况的工具。

# 特定进程CPU

## 内核时间vs.用户时间

一个应用程序所耗时间最基本的划分是内核时间与用户时间。内核时间是消耗在Linux内核上的时间，而用户时间则是消耗在应用程序或库代码上的时间。Linux有工具，如time 和ps，可以（大致）表明应用程序将其时间是花在了应用程序代码上还是花在了内核代码上。同时，还有如oprofile和strace这样的命令使你能跟踪哪些内核调用是代表该进程发起的，以及每个调用完成需要多少时间。

## 库时间vs.应用程序时间

任何应用程序，即便其复杂性非常低，也需要依赖系统库才能执行复杂的操作。这些库可能会导致性能问题，因此，能够查看应用程序在某个库中花费了多少时间就很重要了。虽然为了解决一个问题而去修改库的源代码并不总是实用，但是可以改变应用程序代码来调用不同的库函数，或者是调用更少的库函数。在库被应用程序使用时，trace命令和oprofile工具包提供了分析库性能的途径。Linux加载器ld的内置工具帮助你确定使用多个库是否会减慢应用程序的启动时间。

本章介绍了怎样跟踪单个进程的CPU性能瓶颈。学会了确定一个应用程序消耗的时间是如何分配到Linux内核、系统库，甚至于该应用程序本身的。还学会了怎样找出哪些调用是对内核的，哪些是对系统库的，以及完成它们分别花了多少时间。最后，学习了如何剖析应用程序，确定源代码的哪个特定行消耗了大量的时间。掌握了这些工具之后，就可以启动独占CPU的应用程序，并利用这些工具准确地找出消耗了所有时间的那些函数。

# 特定进程内存

> 内存章节的一开头介绍了CPU的多级高速缓存。其中跟clickhouse为什么快说到的优化高级缓存相关。

产生一个L2高速缓存不命中，处理器就必须到物理内存去取回信息。最终，如果处理器从不访问物理内存（因为它会在LI或者甚至L2高速缓存中发现数据）将是最佳情况。明智地使用高速缓存，例如**重新排列应用程序的数据结构以及减少代码量等方法，有可能减少高速缓存不命中的次数并提高性能**。cachegrind和 oprofile是很好的工具，用于**发现应用程序对高速缓存的使用情况的信息，以及哪些函数和数据结构导致了高速缓存不命中**。

本章介绍了各种可以用于诊断内存性能问题的Linux 工具，展示了可以显示应用程序内存消耗量的工具（ps、/proc），以及显示应用程序中的哪些函数分配了内存的工具（memprof）。本章还包括了可以监控处理器、系统高速缓存和内存子系统有效性的工具（cachegrind、kecachegrind和 oprofile）。本章最后描述了一种可以监控共享内存使用情况的工具（ipcs）。这些工具一起使用就可以跟踪内存的每个分配、这些分配的大小、应用程序中这些分配的函数位置，以及在访问这些分配时，应用程序使用内存子系统的有效性。


# 磁盘

你可以用lsof来确定哪些进程访问了特定分区上的文件。在列出了访问文件的全部PID后，你就能够对每个PID使用strace，找出具有大量I/O的那一个。虽然这种解决方法有效，但它治标不治本，因为访问一个分区的进程可能很多，且关联并分析每个进程的系统调用也很费时。同时，这还可能错过短进程，而在跟踪进程时，还有可能严重减缓它们的速度。

本章介绍了Linux磁盘I/O性能工具，它们能用于提取关于系统级（vmstat）、特定设备（vmstat、iostat、sar）以及特定文件（lsof）的磁盘I/O使用信息。本章说明了不同类型的I/O统计信息，以及如何用I/O性能工具从Linux抽取这些统计数据。此外，本章还对当前工具主要的局限性和未来可发展的领域进行了讨论。


# 网络

本章的主要内容是如何使用Linux 网络性能工具来监控从底层网络接口到高层应用，流经整个系统的网络流量。本章首先介绍的工具可以查询当前物理链接设置（mi-tool、ethtool），以及监控流经底层接口数据包的类型和数量（ifconfig、ip、sar、gkrellm、iptraf、netstat、etherape）。接着介绍的工具可以显示不同类型的IP流量（gkrellm、iptraf、netstat、etherape）和每种流量的数量（gkrllm、iptraf、etherape）。本章还介绍了一种工具（netstat）用来将IP套接字的使用映射到接收/发送每种类型流量的进程上。最后，本章给出了一个网络可视化工具，它可以将流经网络的数据类型和数量与其流经节点之间的关系可视化(etherape)。


# 第8章 性能工具助手

其中有些工具的使用很使用，可以工作中尝试使用。

## tee、script、bash、watch

如同前面章节所述，性能调查中最有价值的步骤之一就是保存在调查过程中发出的命令和产生的结果。这使得你可以在之后对它们进行回顾并寻求新的见解。为了帮助实现这个目的，Linux提供了两个命令∶tee和script，前者能将工具的输出保存为文件，后者能记录每一个按键和屏幕上的每一个输出。这些信息可以保存下来，便于之后查看或者创建脚本来自动执行测试。

自动执行命令很重要，因为它可以减少出错的机会，使你在思考问题时不需记住所有的细节。在你一次性键入又长又复杂的命令行之后，bash shl和watch命令都可以让你周期性地自动执行这些命令。在你保证了命令行的正确性后，bash和watch能够周期性地自动执行它们，不需要再次键入。

本章给出了对调查性能问题有用的各种Linux实用工具的集合。首先介绍的工具如bash、watch、tee和script能自动显示和收集性能数据。之后介绍了gnumeric，该工具可以对基于文本的性能工具所得到的结果进行绘图和分析。之后研究了ldd和objdump，它们可用于发现一个函数属于哪个库。接着本章描述了gdb，它能够被用来调查当前正在运行的应用程序的执行和运行时信息。最后，本章给出了gcc，该工具可生成带符号调试信息的二进制文件，这可以帮助其他性能工具，如oprofile，将事件映射回一个特定的源代码行。


> 建立好基准的指标，确定优化目标（一般10%），利用工具、命令获取有用的统计信息、分析问题、尝试优化、验证效果、提交方案。

---
# 使用性能工具发现问题


> 重点：通过一些基本规则，可以根据路线图的思路，什么情况下做什么样的分析操作、分析命令。

> 内存调优的思路：使用什么的内存类型？什么函数使用的栈？精益求精

## 9.6.6 进程使用的内存类型是什么?

如果进程具有大的VmExe值，这就意味着可执行文件很大。要指明可执行文件中哪些函数导致了这个大小，请转到9.6.8节。如果进程具有大的VmLb值，这就意味着该进程使用了大量的共享库，或是几个体积较大的共享库。要指明哪些库导致了这个大小，请转到9.6.9节。如果进程的VmData值较大并且在增加，这就意味着该进程的数据区或堆在增加。要分析其原因，请转到9.6.10节。

## 9.6.7 哪些函数正在使用全部的栈?

当你确定了哪个函数或函数组消耗了大部分的栈之后，你可以修改应用程序，减少该函数（或这些函数）的调用次数和大小。转到9.9节。

## 9.6.8 哪些函数的文本大小最大?

如果可执行文件使用了相当可观的内存容量，那么确定哪些函数占用了最多的空间，并**删除不必要的函数可能会有所帮助**。对一个可执行文件或符号编译的库来说，可以请求nm 显示所有符号的大小，并用如下命令对它们进行排序∶`nm -S -size-sort`。了解每个函数的大小后，就可能**减少它们的大小或者从应用程序中移除不必要的代码**。

## 9.6.9 进程使用的库有多大?

你知道进程使用了哪些库之后，就有可能淘汰对大型库的使用，或者是用小一点的库来代替它们。但是，这样做的时候必须要小心，因为移除大型库未必会减少整个系统的内存使用量。

## 9.6.10 哪些函数分配堆内存?

当你知道了哪些函数分配了最多的内存之后，就有可能减少被分配的内存大小。由于内存便宜，且越界错误很难被侦测到，因此，为了安全考虑，程序员常常超量分配内存。然而，如果一个特定的分配导致了内存问题，那么仔细分析最小分配就可能在保证安全的前提下，显著减少内存使用量。转到9.9节。

## 词哦

/proc/<pid/fR/中的文件是从文件描述符到实际文件的符号链接。该目录下的ls -la 会显示进程使用了哪些文件。通过了解进程访问的文件，就有可能减少该进程执行的IO 量，将其更均匀地分散于多个磁盘，或者将其迁移到更快的磁盘。

本章提供了综合运用Linux性能工具跟踪不同类型性能问题的方法。虽然这个方法不可能捕捉到每一种可能出错的性能问题，但是它有助于发现一些比较常见的问题。此外，即便你面对的问题在这里没有涉及，你所收集的数据仍然是有用的，因为，这些数据可能会开启调查的不同方面。

---
# 实例


本章中，我们确定了为什么一个应用程序（GIMP过滤器lic）是受CPU限制的。我们计算出了该应用程序的基准运行时间，设置了一个优化目标，保存了一个参考图像以验证我们的优化没有改变应用程序的行为。我们使用了Linux CPU性能工具（oprofile和ltrace）调查究竟为什么该应用程序是受CPU限制的。然后依靠 Web理解了该应用程序是如何工作的，并了解了对其不同的优化方法。我们尝试了几种不同的优化，但是最后还是选择了经典的性能权衡∶增加内存使用量来降低 CPU 使用量。
我们达到了优化目标，之后还验证了优化并未改变应用程序的输出。

本章我们确定了为什么应用程序的特定部分会有高延迟（natilus中的弹出菜单）。我们弄清楚了怎样将弹出菜单的创建进行自动化（xautomation），以及怎样扩展nautilus在创建弹出菜单时花费的时间（100次迭代）。我们用oprofile来了解 nautilus在哪些函数上消耗了全部时间，然后用ltrace和gdb确定哪些共享库调用应该对所有的调用负责。在明确了哪些库调用具有高成本后，我们试图减少或限制它们被调用的次数。针对这种情况，当一个新菜单被创建时，我们保存一个指针指向它，之后使用就可以避免不必要的重新分配。我们创建了一个建议补丁，然后在其上运行性能测试看看是否可以提升性能。性能提高了，并且功能看上去没有受到影响。下一步就是把这个补丁提交给nautilus开发人员讨论。

本章中，我们从一个表现不佳的系统开始，用性能工具找出哪个子系统被过度使用（如vmstat所示的磁盘子系统），以及哪个组件导致了问题（prelink）。接着调查prelink应用程序确定了它为什么有这么多的磁盘/O（用strace）。我们在prelink的文档中发现缓存模式可以大大减少磁盘I/O。研究了缓存模式的性能之后，我们发现它消除的磁盘I/O并不如预期那样多，其原因是它试图对不能预链接的文件进行预链接。之后，我们模拟了一个缓存，避免对不可预链接的文件尝试进行预链接，以此证明它明显减少了磁盘I/O的数量以及快速模式下prelink的运行时间。最后，我们向prelink的作者提交了bug报告，希望该作者能意识到问题并修复它。本章是 Linux 性能追踪的最后一章。


> 这些调优可能对于我来说可能还是太偏向底层了。平时的开发工作，可能是更偏向于理解各个指标的含义，并熟悉使用的工具(mysql、es等)的原理。能理解导致指标异常的可能业务操作原因、并能进行排查，对比分析，来获取压榨机器的最大的性能优化。书上的知识更偏向底层的源码调优。
