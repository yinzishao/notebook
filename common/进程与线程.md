# 进程与线程

**进程是资源分配的最小单位**，意味着进程和资源是1:1，与之对应的一句话就是，**线程是调度的最小单位**，进程和线程是一个1:n的关系。

> 进程中使用多线程就是让共享同一批资源的操作一起进行。

这样可以**极大的减少进程资源切换的开销**。当我们在进行多个操作的时候，他们相互之间在切换时自然是越轻量越好。

我们可以细探一下进程切换的开销。一个进程会独占一批资源，比如使用**寄存器，内存，文件**等。

当切换的时候，首先会保存现场，将一系列执行的中间结果保存起来，存放在内存中的程序的代码和数据，它的**栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合**，这个状态叫做**上下文**。

然后在他恢复回来的时候又需要将上述资源切换回去。显而易见，切换的时候需要保存的资源越少，系统性能就会越好，线程存在的意义就在于此。**线程有自己的上下文**，包括**唯一的整数线程 ID，栈、栈指针、程序计数器、通用目的寄存器和条件码**。

> 可以理解为线程上下文是进程上下文的子集。

程序的编写总是追求最极致的性能优化，线程的出现让共享同一批资源的程序在切换时更轻量，那有没有比线程还要轻的呢？

协程的出现让这个变成了可能，线程和进程是操作系统的支持带来的优化，而协程本质上是一种应用层面的优化了。

协程可以理解为**特殊的函数**，这个函数可以在某个地方**挂起**，并且可以重新在挂起处外继续运行，简单来说，一个线程内可以由多个这样的特殊函数在运行，但是有一点必须明确的是，一个线程的多个协程的运行是**串行**的。

如果是多核 CPU，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内协程却绝对是串行的，无论 CPU 有多少个核。

毕竟协程虽然是一个特殊的函数，但仍然是一个函数。一个线程内可以运行多个函数，但这些函数都是串行运行的。当一个协程运行时，其它协程必须**挂起**。


- [多进程模型底层实现](https://juejin.im/post/5e7732aa518825492e497fe0)
- [node进程模型](../js/node进程.md)

## 线程和进程各自有什么区别和优劣呢？
> - [线程和进程各自有什么区别和优劣呢？](https://zhuanlan.zhihu.com/p/34836949)

*   进程是资源分配的最小单位，线程是程序执行的最小单位。
*   进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来**维护代码段、堆栈段和数据段**，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
*   线程之间的通信更方便，同一进程下的线程**共享全局变量、静态变量等数据**，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好**同步与互斥**是编写多线程程序的难点。
*   但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

# 线程与进程，你真的清楚吗？

> -[线程与进程，你真的清楚吗？](https://cloud.tencent.com/developer/article/1768025)

所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。以上这些信息有一个统一的名字，就是线程上下文，thread context。我们也说过操作系统调度线程需要随时中断线程的运行并且需要线程被暂停后可以继续运行，操作系统之所以能实现这一点，依靠的就是线程上下文信息。


注意到，虽然变量a定义在函数内部，但变量a依然具有全局变量的特性，也就是说变量a放在了进程地址空间的数据区域，即使函数执行完后该变量依然存在，而普通的局部变量随着函数调用结束和函数栈帧一起被回收掉了，但这里的变量a不会被回收，因为其被放到了**数据区**。

这样的变量对每个线程来说也是可见的，也就是说每个线程都可以访问到该变量。

堆区是程序员比较熟悉的，我们在C/C++中用malloc或者new出来的数据就存放在这个区域，很显然，只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源。

栈区

确实，从线程这个抽象的概念上来说，栈区是线程私有的，然而从实际的实现上看，栈区属于线程私有这一规则并没有严格遵守，这句话是什么意思？

通常来说，注意这里的用词是通常，通常来说栈区是线程私有，既然有通常就有不通常的时候。

不通常是因为不像进程地址空间之间的严格隔离，线程的栈区没有严格的隔离机制来保护，因此如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量。

因此，线程局部存储可以让你使用一个独属于线程的全局变量。也就是说，虽然该变量可以被所有线程访问，但该变量在每个线程中都有一个副本，一个线程对改变量的修改不会影响到其它线程。

## 线程上下文切换和进程上下文切换的区别
> - [线程上下文切换和进程上下文切换的区别](https://blog.csdn.net/jackyechina/article/details/53065105)

进程切换分两步
1. 切换页目录以使用新的地址空间
2. 切换内核栈和硬件上下文。

对于linux来说，线程和进程的最大区别就在于**地址空间**。

对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。 所以明显是进程切换代价大

线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

概括：一是处理器中的寄存器其内容切出，二是处理器缓存失效。

---

# Unix进程间通信方式(IPC)
> - [IPC](https://github.com/taizilongxu/interview_python#unix%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8Fipc)

- 管道（Pipe）：管道可用于**具有亲缘关系进程间的通信**，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
- 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还**允许无亲缘关系进程间的通信**。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
- 信号（Signal）：信号是比较复杂的通信方式，用于**通知接受进程有某种事件发生**，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
- 消息（Message）队列：**消息队列是消息的链接表**，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺**
- 共享内存：使得多个进程**可以访问同一块内存空间，是最快的可用IPC形式**。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量**结合使用，来达到进程间的同步及互斥**。
- 内存映射（mapped memory）： mmap 内存映射允许**任何多个进程间通信**，每一个使用该机制的进程通过**把一个共享的文件映射到自己的进程地址空间来实现它**。
     mmap()系统调用使得进城之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read,write等操作。
- 信号量（semaphore）：主要作为**进程间以及同一进程不同线程之间的同步手段**。
- 套接口（Socket）：更为一般的进程间通信机制，**可用于不同机器之间的进程间通信**。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

# 线程间通信

Linux系统中的线程间通信方式主要以下几种:

**锁机制**：包括互斥锁、条件变量、读写锁、**自旋锁**

- **互斥锁**提供了以排他方式防止数据结构被并发修改的方法。**互斥锁**确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。
- **读写锁**允许多个线程同时读共享数据，而对写操作是互斥的。当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
- **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- **自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。
- ***信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量
- ***信号机制(Signal)**：类似进程间的信号处理

**线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。**

## **2、线程通信的方式**

线程通信主要可以分为三种方式，分别为**共享内存**、**消息传递**和**管道流**。每种方式有不同的方法来实现

*   共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。

> volatile共享内存

*   消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。

> wait/notify等待通知方式

> join方式


*   管道流

> Queue队列

> 管道输入/输出流的形式

线程间资源是共享的，讲安全：信号量，锁，原子操作、、
进程间资源是独立的，讲通讯：管道，共享内存、、

## 参考链接
- [进程间通信](https://zhuanlan.zhihu.com/p/165224175)
- [拜托，线程间的通信真的很简单。](https://zhuanlan.zhihu.com/p/138689342)
- [cookbook-并发编程](https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p12_concurrency.html)
