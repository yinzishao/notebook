

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识

- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

---
## 强制缓存
强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

- public：所有内容都将被缓存（客户端和代理服务器都可缓存）
- private：所有内容只有客户端可以缓存，Cache-Control的默认取值
- no-cache：客户端缓存内容，但是是否使用缓存则需要**经过协商缓存**来验证决定
- no-store：所有内容**都不会被缓存**，即不使用强制缓存，也不使用协商缓存
- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

### 内存缓存(from memory cache)和硬盘缓存(from disk cache)

内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：

- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
- 时效性：一旦该进程关闭，则该进程的内存则会清空。

硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。


## 协商缓存
协商缓存就是**强制缓存失效后**，浏览器**携带缓存标识向服务器发起请求**，由**服务器根据缓存标识决定是否使用缓存的过程**，主要有以下两种情况：

协商缓存生效，返回304，如下

同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

> Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。

max-age=0表示不管response怎么设置，在重新获取资源之前，先检验ETag/Last-Modified


# ETAG

### 过程
tag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下：

====第一次请求===

1. 客户端发起 HTTP GET 请求一个文件；
2. 服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200

====第二次请求===

1. 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d044840
2. 服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；

流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办？

答案是**同时使用**，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.

###作用
Etag 主要为了解决 Last-Modified 无法解决的一些问题。

1. 一些文件也许会周期性的更改，但是他的**内容并不改变(仅仅改变的修改时间)**，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
2. 某些文件修改非常频繁，比如在**秒以下的时间内进行修改**，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
3. 某些服务器**不能精确的得到文件的最后修改时间**；

为此，HTTP/1.1引入了 Etag(Entity Tags).Etag仅仅是一个和文件相关的标记，可以是一个版本标记,比如说v1.0.0或者说"2e681a-6-5d044840"这么一串看起来很神秘的编码。但是HTTP/1.1标准并没有规定Etag的内容是什么或者说要怎么实现，唯一规定的是Etag需要放在""内。

### 请求头中的 Cache-Control

Cache-Control 不是响应头的专利，即使是从**浏览器发起的请求**，其头部也可能带有 Cache-Control。请求头中的 Cache-Control 最大的意义是提供一套客户端主动控制代理服务器缓存策略的方案。但由于存在安全风险，实际上目前几乎没有代理服务器实现这个规范。

就像 HTTP 的 PUT 方法上传文件一样，这是存在安全风险的，所以很多服务器并不愿意实现它。

为什么说有安全风险呢？代理服务器上的缓存策略不仅是为了加快访问速度，更重要的一点是**保护上游服务，甚至保护更底层的数据库**。如果代理服务器的缓存策略暴露给**不可信的客户端控制**，那么攻击者则可以强行关闭代理服务器的缓存，直接把请求发送到业务服务器上。如果业务服务器到数据库没有缓存或缓存也由下游请求头控制，那么攻击者就可以**击穿**代理服务器和业务服务器，直接把数据库打爆。

即使是内部服务调用，客户端是可信的。但由于下游服务的开发者并不知道上游服务的获取资源的代价，如果轻易把缓存关掉也会带来隐患。比如上游服务中的某个资源是基于一个慢查询得到的结果，如果下游服务关掉对方的缓存去频繁地刷新这个资源，数据库同样可能被打爆。

所以在某种意义上，客户端请求头中的 Cache-Control 比开启 PUT 方法上传文件还要危险！

但是规范总是太美，总是有人黑着眼眶去实现。比如 Chrome 在开发者工具中勾起 Disable cache 之后，请求头就会被加入一个 Cache-Control:no-cache。然并卵，因为并没有哪个服务器敢实现这个规范。

- [彻底理解浏览器的缓存机制](https://juejin.im/entry/5ad86c16f265da505a77dca4)
- [HTTP 缓存之浏览器刷新行为](https://segmentfault.com/a/1190000010787023)

