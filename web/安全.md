# xss

> - [xss](http://www.cnblogs.com/wangyuyu/p/3388180.html)

可以通过html代码把浏览器的cookie发出去

跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。

**恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。**

XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。

**正如上文所说，如果我们不需要用户输入 HTML 而只想让他们输入纯文本，那么把所有用户输入进行 HTML 转义输出是个不错的做法。Django 内置模版和 Jinja2 模版总是默认转义输出变量的。**

防范：
- HttpOnly类型的Cookie由于阻止了JavaScript对其的访问性而能在一定程度上缓解此类攻击。
- 对用户输入进行过滤来阻止XSS；

---
# CSRF

> - [CSRF](https://juejin.im/post/5bc009996fb9a05d0a055192)

> 个人理解：用户在危险网站的请求下，带着安全网站的cookie去发出坏的请求。攻击者并没有获得第三方的cookie.拥有cookie是指浏览器端拥有cookie。

一、 CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。

二、CSRF 的全称是“跨站请求伪造”，而 XSS 的全称是“跨站脚本”。看起来有点相似，它们都是属于跨站攻击——不攻击服务器端而攻击正常访问网站的用户，但前面说了，它们的攻击类型是不同维度上的分 类。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 **XSS** 或链接欺骗等途径，让用户在本机（**即拥有身份 cookie 的浏览器端**）发起用户所不知道的请求。

三、跨站请求伪造保护

CSRF 中间件和模板标签提供对跨站请求伪造简单易用的防护。某些恶意网站上包含链接、表单按钮或者JavaScript ，它们**会利用登录过的用户在浏览器中的认证信息试图在你的网站上完成某些操作**，这就是跨站攻击。还有另外一种相关的攻击叫做“登录CSRF”，攻击站点触发用户浏览器用其它人的认证信息登录到其它站点。

多窗口浏览器（firefox、遨游、MyIE……）便捷的同时也带来了一些问题，因为多窗口浏览器新开的窗口是具有当前所有会话的。具有其他窗口的cookie。

> 在恶意网站，建立一个攻击网站的表单，诱导用户点击。CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。

### 防范措施

请求应该只浏览而不改变服务器端资源。当然，最理想的做法是使用 REST 风格 的 API 设计，GET、POST、PUT、DELETE 四种请求方法对应资源的读取、创建、修改、删除。

#### (1).Cookie Hashing(所有表单都包含同一个伪随机值)

实现方法非常简单，**首先服务器端要以某种策略生成随机字符串**，作为令牌（token）， 保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登陆验证身份。

!!**这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:>**!!

这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢....由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。

#### (2).验证码

#### (3).One-Time Tokens(不同的表单包含一个不同的伪随机值)

最后的疑问：究竟真的不能获取到第三方的cookie么？是的，通过设置相应的浏览器页面的参数来进行限制

> 应该说是，表单提交等是不受同源策略限制的。**不能获得第三方cookie指的是服务端配好相关的跨域限制**，不能通过js获取到cookie。所以也有了以上的这些防范措施


## 同源策略下为什么还需要防御CSRF

对于Cookie，DOM和XMLHttpRequest（ajax）所有浏览器都会严格遵守同源策略。但是也有例外，`如<img>标签，<script>标签，<iframe>`标签等的链接会自动加载，更重要的是，**表单提交也是可以跨域的**, 见此[原因](https://www.zhihu.com/question/31592553/answer/190789780)

来源：

- [关于ajax请求的安全，如何避免csrf类似的攻击？ - 郭小成的回答 - 知乎](https://www.zhihu.com/question/39011147/answer/152441324)

CSRF 攻击的原理，就是利用由于浏览器的同源策略对以上嵌入资源不做限制的行为进行跨站请求伪造的。


---
# 如何防止CSRF攻击？

> - [前端安全系列（二）：如何防止CSRF攻击？-美团技术团队](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

## CSRF Token
CSRF Token的防护策略分为三个步骤：

1. 将CSRF Token输出到页面中

2. 页面提交的请求携带这个Token

3. 服务器验证Token是否正确

当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。

这种方法要比之前检查Referer或者Origin要安全一些，**Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求**。

通常，开发人员**只需为当前会话生成一次Token**。在初始生成此Token之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端必须验证请求中Token的存在性和有效性，与会话中找到的Token相比较。如果在请求中找不到Token，或者提供的值与会话中的值不匹配，则应中止请求，应重置Token并将事件记录为正在进行的潜在CSRF攻击。

### 分布式校验
在大型网站中，使用Session存储CSRF Token会带来**很大的压力**。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。

由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样**在校验时无需再去读取存储的Token，只用再次计算一次即可**。

这种Token的值通常是使用**UserID、时间戳和随机数，通过加密的方法生成**。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。

在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。

> 这里跟当前登录的UserID进行比较，其实隐含着跟cookie(会话状态)比较了，其实跟下面的双重cookie的方案一样的思路?但不一定是从cookie拿，从redis等拿。

### 总结
Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。

但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。

## 双重Cookie验证

在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。

那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。

双重Cookie采用以下流程：

- 在用户访问网站页面时，**向请求域名注入一个Cookie**，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。
- 在前端向后端发起请求时，取出Cookie，**并添加到URL的参数中**（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。
- 后端接口验证Cookie中的字段与URL参数中的**字段是否一致，不一致则拒绝**。

此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。

当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。

### 总结
用双重Cookie防御CSRF的优点：

- 无需使用Session，适用面更广，易于实施。
- Token储存于客户端中，不会给服务器带来压力。
- 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。

缺点：

- Cookie中增加了额外的字段。
- 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。
- 难以做到子域名的隔离。
- 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。

> django算是上面两个方法的整合？：既通过后端生成相关token输出给前端，也通过双重cookie释放服务端压力。子域名问题没有解决，所以其实还是第二个方案？有待思考。

## 总结

简单总结一下上文的防护策略：

* CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。

* CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。

* 保证页面的幂等性，后端接口不要在GET页面中做用户操作。

为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。

> - Token验证: 是一种session的策略，生成token后发给前端，后携带给请求。这时候需要从服务端进行匹配对比是否正确。分布式和服务端压力较大。
> - 双重Cookie验证： 也就是cookie的策略，转移给前端。通过cookie和请求携带值的对比进行对比，服务端没有压力，但是在跨域情况下会有子域名的其他域名xss攻击互相影响的风险。


---

# 总结
以上介绍的防御CRSF攻击的方案，都可以概括为：颁发一个令牌token，放在严格遵循同源策略的媒介上来识别请求是否可信。 对于表单提交来说，令牌token存储在表单DOM上，其他站点无法获取到。对于Ajax提交来说，令牌token存储在Cookie上，其他站点无法获取到。

参考链接：
- https://www.zhihu.com/question/39011147/answer/152441324
- https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html
- http://www.django-china.cn/topic/580/
- http://www.cnblogs.com/wangyuyu/p/3388180.html
- https://www.jianshu.com/p/0e52c58cf93f
- https://juejin.im/post/5bc009996fb9a05d0a055192 这个写的很详细
- https://www.zhihu.com/question/39011147/answer/152441324
- https://www.zhihu.com/question/31592553/answer/190789780
- [前端安全系列（二）：如何防止CSRF攻击？-美团技术团队](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)
- [不要再问我跨域的问题了](https://juejin.cn/post/6844903639304110093)
- [csrf](./csrf.md)

---
## 点击劫持
点击劫持（clickjacking）是一种在网页中将恶意代码等隐藏在看似无害的内容（如按钮）之下，并诱使用户点击的手段。

Django在X-Frame-Options middleware的表单中中含有 clickjacking protection，它在支持的浏览器中可以保护站点免于在frame中渲染。 也可以在每个视图中禁止这一保护，或者配置要发送的额外的协议头。

对于任何不需要将页面包装在三方站点的frame中，或者只需要包含它的一部分的站点，都强烈推荐启用这一中间件。
