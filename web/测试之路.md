# 背景

项目中说测试也说很久了，期间也有一段时间专注去进行测试，但最终效果都不是很好。

# 原因

既然这样，为什么不放弃测试呢。我觉得有以下的几点原因：

- 最直接也是最重要的，减少我们的bug的出现。这里的bug我也觉得有几个方面。
    - 新需求。就是直接写的新功能的，原因大概可能无法覆盖到一些边界条件导致的。
    - 旧逻辑。这种就是经历最多的了，改了一处代码，莫名其妙影响了其他的逻辑代码，导致错误异常。
    - 重构。项目没有很好的工程规范与实践，技术方案也是赶鸭子。导致经常重构，重构总是浪费各种时间进行旧代码逻辑的校验检查。

- 改变写代码的思路。虽然说看过一些TDD，但也没有真正悟道。但之前写的测试其实对自身代码的架构、分层还是会有很大的帮助的。带领我们用另一个角度去思考编程。
    - 外部接口或者某一方面的mock，会让你在测试的时候，会思考如何根据特性进行聚合管理，文件放置结构等，怎么样才能更好进行测试的书写，其实也使我们的代码更有条理清晰。
    - 测试用例的书写，会让你写代码的时候，会思考这个函数是否不够解耦，会不会放了太多参数或者依赖逻辑进去，导致测试用例很难书写。
    - 各种外部依赖。会让我们去想，如何在测试的时候，进行绕过，中间件设计的时候是否需要进行这样的考虑解耦。其实同样的思路，也是能方便我们本地开发，一举两得。例子就是测试的时候，是否应该可以放过权限，测试的时候可以不用把所有的流程都构建成功。其实这个也涉及到我们用例和代码的思考、如何设计（自我仍需要多多思考总结）
    - 测试数据的生成。脱离数据库的固有思想的约束，各种数据和依赖都是能无中生有的。这样的思想也不仅仅适用于测试。其他的工作需求也是类似的，例如压测，例如前后端联调。

这些都能让我们打破固有的思维约束，提高自身的编码能力和思维。也能提高我们的工程规范与流程，提高我们工作的开发效率。

# 难点

工作中的一些体会：

- 数据库依赖
- 外部服务
- 测试流程

## 数据库依赖

数据服务项目，最大的问题应该是数据库的表和数据究竟是怎么来的？经历了几个阶段

1. django的测试表的生成。思路其实是根据django的文档介绍来的，通过ORM生成相关的数据库表。期间也遇到了些挫折，因为对原生的ORM做了一些魔改，导致测试表的生成会发生原生model和项目自身的model冲突的问题。最后通过禁用原生表的创建和代码脱离原生model的依赖进行解决的。基础也是因为没有用到原生用户和权限的太多功能（思考：不要太依赖框架本身）

2. 随着项目发展，数据中台的接入。有了统一了的数据仓库，各个库与表都能比较好的约束和录入。以此在CI/CD上自动化构建了各个数据库的镜像。也能构建公用的ORM代码。数据库镜像的构建不仅简化了自身测试的流程，也能在CI/CD中支持各种数据校验和测试，也方便了本地开发测试的时候数据库的迅速构建。

## 外部服务

自从项目开始微服务后，单体的代码拆成了5、6个代码仓库。其中的一些服务还得彼此依赖，导致写测试的时候发现整个测试流程比较复杂。

思考了一下，觉得有几个点需要注意一下的：

1. mock外部服务。对于Python这样的动态语言，可以直接通过TestCase的直接拦截patch掉外部服务，然后进行定制的返回。对于go，java等静态语言，就比较需要注意了，需要做一些依赖注入。但python搞成这样，我觉得是得不偿失的。

2. mock服务应该怎么写？这里没想得太好，现在的做法就是测试需要什么数据就伪造一下。这样会不会到最后相当于把整个项目的逻辑实现了？

3. mock服务部署。不单单是一个项目会用到该服务的mock，其他项目也会用到。所以不应该由写用例的代码去写mock（现在的做法），应该是由服务自身提供相应的mock数据返回。暂时想到做法的思路有：

- 定义好接口的文档，通过API工具生成mock。例如：最近使用接触到的yapi工具。不仅能使接口更可阅读，也可以通过高级mock，返回定制需要的数据。
    - 这样做的好处是，统一接口的流程与规范，随着接口的更改，其测试用例、数据也必须做相应的更改和维护。避免现在经常会出现的情况：频繁更改后，测试用例难以追踪，也无法跟上，导致废弃，并反而造成工作负担。
    - 坏处，我觉得可能是mock数据的伪造成本，无状态，对一些复杂的前后因果业务逻辑无法伪造。会不会依赖工具，不够灵活，最后被迫自己定制。

- 服务自身设计的时候考虑上提供mock服务。其他项目可以简单通过构建其mock镜像进行提供服务。
    - 好处。服务自身业务，理解方便，快速、灵活构成mock。并且更改代码后也能快速做成更改。
    - 坏处。可能就是如何脱离服务自身的依赖，并顺利完成自身的mock。上面其实也是有同样的问题，简单来说就是mock数据的生成。

- 之前的一个思路是独立一个mock的代码仓库。整合所有需要的依赖，独立到该项目里，实现各自的mock逻辑。但我觉得脱离了自身的服务，后续维护很难，成本也太高了。虽然录入，管理更方便了。

# 测试流程

测试流程是因为测试的工程规范没有接触过，只是摸石头过河。

阶段一。所有的数据表都在本地数据库通过ORM创建起来，也就是django文档的那一套。其中比较方便的好处就是方便调试了。

阶段二。CI上跑，数据库依赖原生的Mysql镜像进行构建，通过ORM进行创建相关的表格，其实跟阶段一差不多，只是数据库换成了镜像启动。其中遇到的问题就是数据库的设置不相符（时区、group by）导致的用例错误，也很好更改了相关的代码逻辑写法。

阶段三。我觉应该就是依赖于中台构建的数据库镜像与上面所说的外部服务的mock（yapi、服务自身的mock）。不管是CI上，或者本地上都应该脱离各种依赖，简单来说就是能够通过docker-compose能完成完整的测试流程。也在以此为目标实践中。

# v2

2020.07.17

## 背景

本地开发环境搭建较困难，测试流程不完善统一。随着基础设施逐渐完善，先行搞一版统一开发规范和流程。先做个摩托车后续再造灰机。

## 本地开发

- Q: 怎么配这些配置文件
- Q: 怎么进行用户相关的登录或者绕过
- Q: 怎么获取到用户相关的权限或者绕过
- Q: 有没有一些测试数据让我debug一下

## mock相关

先采用统一mock的相关接口到一个独立的项目里面的方案。

- 作用：主要是提供了登录、用户校验、权限、相关的mock数据

- 优点：没有数据库、redis等外部依赖，数据写死、单纯的提供mock数据，比较简单方便运行。

- 缺点：但是数据因为是写死（例如权限），更新后的维护成本？


## 本地开发流程

在本地公共的数据库中预先装载了部分数据，方便本地测试。有需要自行插入一下需要的数据。

做法：
- 主要是把本地开发一些数据、ES连接等依赖的配置写好在apollo上，通过统一的apollo进行本地开发配置的拉取，从而避免每次的询问。
- 然后通过compose启动服务（项目自身的基本镜像、mock服务、相关项目依赖镜像），通过上面说的mock服务绕过了各种外部依赖和mock。
- 本地开发只需要执行mock相关的用户登录，就能直接去到业务逻辑开发的代码了。
- 挂载本地代码进镜像里面，而且是通过runserver启动的，所以直接编辑代码就能自动重启，方便调试。

TODO: 平常直接print原始打点法，效率可能不高，尝试pycharm能不能直接连接docker容器方便打点调试。

> 讨论：本地公共的数据维护成本？

## 测试流程相关

本地开发和测试其实差不多。

区别就是本地开发为了方便，建立了一个公共的数据库和数据的准备。

做法:
- schema已经生成好的各个数据库、ES的数据存储相关的镜像，并已经预先创建好相关的表。
- compose启动好服务。
- ./test.sh执行相关用例

缺点：依赖过多，启动较慢。CI流程的优化与统一。


## 数据相关

测试用例的数据如何进行伪造

- 一种方法是自行在测试用例进行数据的伪造。例如用户优惠券之类的简单数据。

- 另一种方法是测试前提前装载进数据存储层，方便链条过长的数据伪造。现在的通用版的相关的数据是通过挂载进mysql的初始化脚本。

```
volumes:
  - ./fixture/adData.sql:/docker-entrypoint-initdb.d/adData.sql
```

讨论：测试数据伪造、存放和维护


TODO: 测试用例规范。待积累经验。

---
# 参考

- 总结的很好：[微服务架构设计：测试](./《微服务架构设计》.md#第9章与第10章测试)

---
# 阅读微服务架构后的工作思考

## 单元测试与功能测试的界限

如果要测数据相关类，也就需要插入数据到数据库，并测试查询数据库和返回数据是否正常。

所以会有两种方式进行业务逻辑类相关的单元测试：

- 调用到的数据类提供相关的mock类，不跟数据库进行交互，提供相应的假数据。
- 业务相关的单元测试直接沿用数据类测试的插入数据，直接提供给相关的调用类进行测试

优缺点：

- 优点：不需要再写数据库的mock类，减轻代码量，并且沿用数据查询逻辑，也相当于功能测试
- 缺点：不够灵活，依赖数据库。对于各种测试逻辑可能需要伪造各种数据插入，成本反而更高了。

## 依赖注入的书写
TODO


---
08.28

# 并行测试

[并行与并发的区别](https://blog.csdn.net/weixin_33809981/article/details/88039660)

一谈到并行测试，很多人自然而然的想到了使用多线程来执行测试的方式。其实多线程执行的方式叫做并发，并不能做到完全的并行，特别是针对目前大部分虚拟机都是多核CPU，并发测试并不能完全发挥硬件的计算能力。让我们先看看并发和并行的概念吧：

- 并发：多个任务在同一个 CPU 核上按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。针对 CPU 内核来说，任务仍然是按细粒度的串行执行。
- 并行：区别与串行，多个任务真正的分配到不同的 CPU 内核上去执行的，它们是真正的同时执行。


## 如何解决数据库并发事务问题？

- 拆分更细粒度的单元测试。对一些业务相关的逻辑，避免数据库的遗漏。以达到移除数据库的并发可能性。

- 数据库相关逻辑独立测试。可以根据表的粒度进行并发测试。
