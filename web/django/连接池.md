# connection

工作中纯服务端的项目用到了线程池和django的ORM部分。django 的数据库连接在每一个线程中开启一份，并在查询完毕后自动关闭连接。

使用CONN_MAX_AGE减少数据库请求

这个参数的原理就是在每次**创建完数据库连接之后**，把连接放到一个**Theard.local的实例中**。在request请求开始结束的时候，打算关闭连接时会判断是否超过CONN_MAX_AGE设置这个有效期。这是关闭。每次进行数据库请求的时候其实**只是判断local中有没有已存在的连接**，有则复用。

TODO: 自己动手测试一下配置CONN_MAX_AGE的作用，是否之前的mysql的time_wait是真的因为频繁创建引起的。按理来说都是会被正常close掉？但还是需要等待time_wait。

## 注意问题

### 多线程连接数过多
基于上述原因，Django中对于CONN_MAX_AGE的使用是有些限制的，使用不当，会事得其反。因为保存的连接是基于线程局部变量的，因此如果你部署方式采用**多线程**，必须要注意保证你的最大线程数不会多余数据库能支持的最大连接数。另外，如果使用开发模式运行程序（直接runserver的方式），建议不要设置CONN_MAX_AGE，因为这种情况下，每次请求都会*创建一个Thread*。同时如果你设置了CONN_MAX_AGE，将会导致你创建大量的不可复用的持久的连接。

threading.local 是一个全局变量，local的属性是**非线程共享的**，也就是在**每一个线程中都会有单独一个数据库连接实例创建**，因为代理及包装的原因，该连接实例为对应backend里的连接（比如，pymysql.connections.Connection）。

> threading.local源码见下

在线程池的情况下，**close_old_connections方法是不能将线程中的数据库连接关闭的**。

> 为啥不能关闭？TODO：多线程模式下的连接工作原理。新版本应该做了优化。

- [django 数据库连接模块解析及简单长连接改造](https://blog.csdn.net/u010477231/article/details/77576357)
- [reduce-db-conn-with-django-persistent-connection](https://www.the5fire.com/reduce-db-conn-with-django-persistent-connection.html)

---

TODO:django runserver 多线程


django.db.close_old_connections：每个请求的开始和结束都会清理无用或者过时的连接。

ConnectionHandler类：相当于django.db.connections。
- django/db/utils.py： 通用的不同的数据库配置的各自引擎装载、不同数据库的管理清理与创建。
- django/db/utils.py:151：线程local存储数据库连接。
- django/db/utils.py:212：这里根据配置获取各个不同的数据库引擎的backend然后创建连接。

关键点：

TODO: 打断点试下找到是什么时候创建与销毁连接的，复用么？如何复用的？

BaseDatabaseWrapper的connection是通过close_if_unusable_or_obsolete每次都close了，但是为什么在ConnectionHandler里面能知道，也就是从那里delete_attribute？下一次是在哪里创建的？？

---
# django连接池的文档
- [数据库](https://yiyibooks.cn/xx/Django_1.11.6/ref/databases.html)

详细地说，当Django需要的时或者**当前不存在数据库连接**时，它会**自动**的与数据库之间建立连接————要么是因为这是第一次连接，要么是因为先前连接被关闭。

在每个请求结束，如果它已经到达了最长存活时间或者它处在一个不可恢复的错误状态时，Django就会关闭连接。 在处理请求中如果有任何数据库错误产生，Django就会检查是否连接仍然工作，不工作就关闭它。 因此，数据库错误最多影响一个请求；如果连接变得不可用，下一个请求将获得新的连接。

## 注意问题：

### CONN_MAX_AGE低于数据库的连接时间
在每个请求开始时，Django会关闭那些达到其最大寿命的连接。如果你的数据库在一段时间后会关闭空闲连接，则应将

### 长连接会话
当Django建立与数据库的连接时，它会根据所使用的后端设置恰当的参数。如果启用长连接，则不会再对每个请求重复设置。如果修改连接的隔离级别或时区等参数，则应在每个请求结束时恢复Django的默认值，在每个请求开始时强制使用适当的值，或者禁用长连接。

---
# Django数据库连接池
- [Django数据库连接池](https://lockshell.com/2019/08/28/django-db-connection-pool/#%E4%B8%BA%E5%95%A5django%E4%B8%8D%E6%94%AF%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%B1%A0)

## 为什么不用连接池

- 第三方工具已经提供了，更专注做得更好。Django并不需要做全栈。
- 用从pool里取连接代替新建连接，向pool归还连接代替关闭连接，然后在worker在整个请求期间都持有连接并不是**真正的连接池**(访问完数据库后，马上归还连接)。这需要跟worker数一样多的数据库连接，除了能在各个worker循环使用外，基本跟长连接是等效的。长连接也有自己的优点，**消除了新建连接的开销，避免的池化的复杂性，适用于不需要手动管理事务的中小型站点**。
- 首先要操心的不是数据库，AWS之类的云计算已经很牛了，按需扩容，多关注下缓存吧。
- MySQL的连接非常轻量和高效，大量的Web应用都没有使用连接池。

异步或者多线程任务则比较需要。

> peewee也是每个线程单独一个连接。新版本异步任务async这些更符合连接池场景。

## 连接池的优点
数据库连接池（Connection pooling）的核心思想是连接复用，通过建立一个数据库连接池以及一套连接使用、分配和管理策略， 使得该连接池中的连接可以得到高效、安全的复用。主要有以下优势：

- 减少资源开销：减少连接的创建，避免了数据库连接初始化和释放过程的时间和资源开销，加快系统的响应速度
- 统一连接管理：预先设定超时时间、连接数量，避免数据库连接操作中可能出现的资源泄露，增强系统的稳定性
其实，我们在连接池里建立的连接生存周期也可以比较长，这样能充分利用长连接的优点减少连接的开销； 同时，连接池又可以帮助我们更方便管理DB连接，减少后端服务到MySQL的连接数。

## 为何要在Django中用连接池
说了这么多，有两点是确定的：

- Django原生支持长连接，但不支持连接池
- 连接池还是有很多优点的，也有很多成熟的三方库支持

Django服务，一般情况下**每个线程都维护自己的连接**，有多少线程就会就有多少连接；如果**采用分布式部署，线程数较多**，则会建立较多的连接。不仅非常消耗资源，还可能出现MySQL连接数不够用的情况。

在使用Gunicorn作为Django的前置服务时，对于**数万的异步请求，Gunicorn有自己的worker pool，每个异步worker进程会创建若干协程来处理请求**。协程比线程和进程更加轻量，Gunicorn因此能很好的处理大量并行的请求。(Gunicorn如果配置同步的worker，每一个进程只需要一个DB连接，这样总的连接数会变少，但是并发能力就上不去了。)

但是，对于**每一个**协程转发的请求，**Django ORM都需要创建并维护一个数据库连接**。成千上万个协程，意味着成千上万个连接，MySQL数据库的连接很快就耗尽。 这样就会出现大量创建数据库连接失败，从而导致请求失败。在客户端与服务端之间的网络缓慢时，情况会更加严重。

## Django连接池方案

SQLAlchemy有一个成熟的连接池实现，支持Django使用连接池。通过ManagerProxy，代理模式，然后**patch掉connect方法**，让其连接变成SQLAlchemy的manager.connect方法建立的连接池的连接。

用从pool里取连接代替新建连接，向pool归还连接代替关闭连接，然后在worker在整个请求期间都持有连接并算不上真正的连接池。这需要跟worker数一样多的数据库连接，除了能在各个worker循环使用外，基本跟长连接是等效的。

所以**需要在访问完数据库后，马上归还连接，而不是在请求完成时再归还**。 所以可以patch掉数据库的执行操作，在其前后进行connection的close操作，进行归还。

> 具体看参考链接！！

- [Database pooling vs. persistent connections](https://groups.google.com/forum/#!topic/django-developers/NwY9CHM4xpU)


> 思考场景：django大多数都是进程部署方式，即使多线程数也较小，一般场景没必要进行数据库连接池。长连接也能避免池化的复杂性。而在一些协程操作的场景下更需要。但要思考，如果是协程请求业务逻辑完才归还，会导致连接不够用，应该做到最细粒度的归还。

> 还是有点懵，要集合各个程序的部署方式（多线程、多进程、协程？），从完整生态技术从低往上对比思考才行。TODO：尝试一些django3.0的async特性

