# 高性能服务系统构建与实战

标签（空格分隔）： 未分类

---

阅读的主要是第三部分 系统间的通信

包括系统间通信常使用的信息协议、网络 I/O 模型，以及网络 I/O 模型如何影响系统间通信的性能。

比较浅的介绍了阻塞模型指出：阻塞模型的问题关键不在于是否使用了多线程（包括线程池）处理并发请求，而在于accept、read的操作点都被阻塞。分析对比阻塞、同步说得不太好，应该从用户态和内核态说明。

然后7.3说到同步非阻塞模式，是通过应用层次和多线程。引出7.4多路复用NIO：
- Channel：连接操作系统的渠道
- Buffer
- Selector：轮询代理器。负责询问操作系统事件发生。单独线程。
但是基于同步模型。引出7.5异步I/o

异步 I/O（又称为 AIO）则是采用"订阅—通知"工作模式∶ 即应用程序向操作系统注册I/O 监听，然后继续做自己的事情。当操作系统发生 I/O 事件，并且准备好数据后，再主动通知应用程序，触发相应的函数

注意：Linu 操作系统版本（例如 CentOS 等）下由于没有这种异步 技术，所以使用的是 epoll 上文介绍过的 种多路复用 I/O 技术 实现）对异步 进行模拟。：

在 Java AIO 架中 由于应用程序不是“轮询”方式，而是“订阅一通知” 方式，所 以不再需要“ Selector （选择器）了， 改由 Channel 通道直接操作系统注册监昕。

引出Netty的好处，封装。Boss=Selector，监听连接。工作线程：负责指派给它的网络连接事件的监听。

Selector 可以在主线程上面操作，也可以在一个独立的线程上进行操作。在 Netty 中，这里的部分工作就交给 Boss 线程完成，而且建议读者使用线程池技术。Boss线程负责发现连接到服务器的新的 Channel（SocketServerChannel的ACCEPT事件），并且将这个Channel经过检查后注册到 Work 连接池的某个 EventLoop线程中。而当 Work 线程发现操作系统有一个它感兴趣的 I/O事件时（例如 SocketChannel的READ事件），则调用相应的 ChanneHandler 事件。当某个 Channel 失效后（例如显示调用 ctx.close）），这个 Channel 将从绑定的EventLoop 中被剔除。

channel则封装了不仅网络，还封装了文件的I/O通道。然后通过责任链模式进行pipeline过滤处理。

最后在7.8章节提出线程池的重要性。对ThreadPooLExecutor 类进行讲解：等待队列、核心线程、非核心线程、空闲时间。还介绍了等待队列的各种数据结构种类。最后说了一下拒绝任务的处理。

> Netty的原理与流程：主线程监听、注册channel（事件）到事件循环的工作线程。工作线程池是eventloop，封装selector的事件状态，一直轮询

> 这个章节从字面来说还是比较肤浅的，都是很简短的概念，特别是同步与阻塞的讲解。适合当反面思考的例子。Netty、线程池的流程反而能入门下。


