# time wait

在web00上看到很多time wait

今天测试了一下，用requests的session就可以解决这个问题 https://2.python-requests.org/en/v2.8.1/user/advanced/

---
# 为什么Go的web框架速度还不如Java

https://www.zhihu.com/question/360929863/answer/980246776

首先呢，Java也是编译型的语言。Java的编译分为两个步骤，第一步是从源代码到bytecode，也就是.class文件。我们日常看到的java jar包，其实就是bytecode的分发形式。第二步是在运行时，java虚拟机会和jit合作，把bytecode在需要的时候编译成native code。所以说呢，你这个链接里的跑分比较，其实大家跑的都是编译后的native code。

其次，web框架不单单要看中对语言的执行效率，还要看IO的效率。当然这也没什么花头，java的很多框架和go的异步IO如出一辙, 说白了还是借助linux操作系统中的epoll等来减少进程堵塞。于是很多跑分中，语言的执行效率变得次要，在充分优化和合理使用nonblocking IO的情况下，一些解释型语言也能取得很好的成绩。

最后，也是最重要的，其实你看这些跑分，框架的性能都好的不行不行的，远远超过一般应用的需要。其实在实际应用中，我们的业务逻辑会更复杂，上下游服务也会更多，其实就算是好多人瞧不起的增删改查操作，并发大了也极容易产生性能瓶颈。换句话说，编程语言和框架本身是不容易成为性能瓶颈的。所以，**我建议应该更多的从开发难易程度，以及以后项目长期维护的成本上来选择语言和框架，而不是看跑分**。

> 实际应用做，业务会更复杂。觉得不看重的增删改查，并发大了，也是有性能问题的。从开发难易程度，以及以后项目长期维护的成本上来选择语言和框架，而不是看跑分


[阿里巴巴淘系技术](https://www.zhihu.com/question/360929863/answer/1650981553)

第三点 prefork ， java netty 等是直接对于线程操作，可以更加定制化的优化性能，而 go 的 goroutine 需要的是一个通用协程，目的是降低编写并发程序的难度，在这个层次上难免性能比不上一个优化的非常出色的 Java 基于线程操作的框架；但是直接操作线程的话需要合理控制好线程数，这是个比较头疼的调优问题(特别是对于新手来说)，而 goroutine 则可以不关心池子的大小，使得代码更加优雅和简洁，这对于工程质量保障其实是一个提升。另外这里存在 prefork 是由于 go 没法直接操作线程，而 fasthttp 提供了 prefork 的能力，使用多进程方式来对标 Java 的多线程来进一步提高性能。

---

## 问题一：TCP存在粘包问题吗？

先说答案：TCP 本身并没有粘包和半包一说，因为 TCP 本质上只是一个传输控制协议（Transmission Control Protocol，TCP），它是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。

所谓的协议本质上是一个约定，就好比 Java 编程约定使用驼峰命名法一样，约定的意义是为了让通讯双方，能够正常的进行消息互换的，那粘包和半包问题又是如何产生的呢？

这是因为在 TCP 的交互中，数据是以字节流的形式进行传输的，而“流”的传输是没有边界的，因为没有边界所以就不能区分消息的归属，从而就会产生粘包和半包问题（粘包和半包的定义，详见上一篇）。所以说 TCP 协议本身并不存在粘包和半包问题，只是在使用中如果不能有效的确定流的边界就会产生粘包和半包问题。

- [Socket粘包问题终极解决方案—Netty版（2W字）！](https://juejin.cn/post/6917043797684584461): netty的源码分析
---

# ssl

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
