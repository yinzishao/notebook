# keepalive

### 如何理解 TCP 的 keepalive?
大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。

试想一个场景，**当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的**。

这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。

在 Linux 下，可以这样查看相关的配置:

```
sudo sysctl -a | grep keepalive
// 每隔 7200 s 检测一次
net.ipv4.tcp_keepalive_time = 7200
// 一次最多重传 9 个包
net.ipv4.tcp_keepalive_probes = 9
// 每个包的间隔重传间隔 75 s
net.ipv4.tcp_keepalive_intvl = 75
```
不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么?

站在应用的角度:

- 7200s 也就是两个小时检测一次，时间太长
- 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接
因此是一个比较尴尬的设计。

### Keepalive 有什么用?

TCP 的连接, 实际上是一种纯软件层面的概念, 在物理层面并没有 "连接" 这种概念. TCP 通信双方建立交互的连接, 但是并不是一直存在数据交互, **有些连接会在数据交互完毕后, 主动释放连接, 而有些不会**. 在长时间无数据交互的这段时间内, 双方都可能会出现掉电, 死机, 异常重启等各种意外, 当这些意外发生之后, 这些 TCP 连接并未来得及正常释放, 在软件层面上, 连接的另一方并不知道对端的情况, 它会一直维护这个长连接, 长时间的积累 会导致非常多的半打开连接, 造成端系统资源的消耗和浪费, 为了解决这个问题, 在传输层可以利用 TCP 的KeepAlive 机制实现来实现.

TCP KeepAlive 的基本原理是, **隔一段时间给连接对方发送一个探测包**, 如果收到对方回应的 ACK, 则认为连接还是存活的, 在超过一定重试次数之后还是没有收到对方的回应, 则丢弃该 TCP 连接.

局限性:
1. TCP KeepAlive 检测的方式是发送一个 prbe 包, 会给网络带来额外的流量.
2. **只能在内核层级检测连接的存活与否, 连接存活并不代表服务一定可用**. 所以 TCP KeepAlive 对于应用层程序的价值相对较小, **一般程序会在应用层**
自己实现自己的心跳功能.

---
# 详解HTTP 与TCP中Keep-Alive机制的区别
> - [详解HTTP 与TCP中Keep-Alive机制的区别](https://cloud.tencent.com/developer/article/1430022)

#### 1 HTTP中的keep-alive

##### 1.1 为什么HTTP是短连接
众所周知，HTTP是**短连接**，**client向server发送一个request，得到response后，连接就关闭**。之所以这样设计使用，主要是考虑到实际情况。例如，用户通过浏览器访问一个web站点上的某个网页，**当网页内容加载完毕之后，用户可能需要花费几分钟甚至更多的时间来浏览网页内容，此时完全没有必要继续维持底层连接**。当用户需要访问其他网页时，再创建新的连接即可。

因此，HTTP连接的寿命通常都很短。这样做的好处是，**可以极大的减轻服务端的压力**。一般而言，一个站点能支撑的最大并发连接数也是有限的，面对这么多客户端浏览器，不可能长期维持所有连接。每个客户端取得自己所需的内容后，即关闭连接，更加合理。

##### 1.2 为什么要引入keep-alive
通常一个网页可能会有很多组成部分，除了文本内容，还会有诸如：js、css、图片等静态资源，有时还会异步发起AJAX请求。只有所有的资源都加载完毕后，我们看到网页完整的内容。然而，一个网页中，可能引入了几十个js、css文件，上百张图片，**如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了**。

基于此背景，我们希望连接能够在短时间内得到复用，在加载同一个网页中的内容时，尽量的复用连接，这就是HTTP协议中keep-alive属性的作用。

- HTTP 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；
- http 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。

##### 1.3 如何处理keep-alive
对于客户端来说，不论是浏览器，还是手机App，或者我们直接在Java代码中使用HttpUrlConnection，只是负责在请求头中设置Keep-Alive。而**具体的连接复用时间的长短，通常是由web服务器控制的**。

这里有个典型的**误解(?)**，经常听到一些同学会说，通过设置http的keep-alive来保证长连接。通常我们所说的长连接，指的是一个连接创建后，除非出现异常情况，否则**从应用启动到关闭期间，连接一直是建立的**。例如在RPC框架，如dubbo，服务的消费者在启动后，就会一直维护服务提供者的底层TCP连接。

在HTTP协议中，Keep-Alive属性保持连接的时间长短是**由服务端决定的**，通常配置都是在几十秒左右。

说明如下：

- maxKeepAliveRequests：一个连接上，最多可以发起多少次请求，默认100，超过这个次数后会关闭。
- keepAliveTimeout：底层socket连接最多保持多长时间，默认60秒，超过这个时间连接会被关闭。

##### 1.4 JDK对keep-alive的支持
在客户端，我们可以通过HttpUrlConnection来进行网络请求。当我们创建一个HttpUrlConnection对象时，其底层实际上会创建一个对应的Socket对象。我们要**复用的不是HttpUrlConnection，而是底层的Socket**。

这段话的含义是：当通过URLConnection.getInputStream()读取响应数据之后(在这里是HttpUrlConnection)，应该调用InputStream的close方法关闭输入流，JDK http协议处理器会将这个连接放到一个连接缓存中，以便之后的HTTP请求进行复用。

翻译成代码，当发送一次请求，得到响应之后，不是调用HttpURLConnection.disconnect方法关闭，这会导致底层的socket连接被关闭。

#### 2 TCP协议中的keep-alive
首先介绍一下HTTP协议中keep-alive与TCP中keep-alive的区别：

- HTTP协议(七层)的Keep-Alive意图在于连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。
- TCP协议(四层)的KeepAlive机制意图在于保活、心跳，检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。

其中：

- tcp_keepalive_intvl：keepalive探测包的发送间隔，默认为75秒
- tcp_keepalive_probes：如果对方不予应答，探测包的最大发送次数，默认为9次。即连续9次发送，都没有应答的话，则关闭连接。
- tcp_keepalive_time：连接的最大空闲(idle)时间，默认为7200秒，即2个小时。需要注意的是，这2个小时，指的是只有keepalive探测包，如果期间存在其他数据传输，则重新计时。


然而，tcp的keep-alive机制，说实话，有一些鸡肋：

- **keepalive只能检测连接是否存活，不能检测连接是否可用**。例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。
- **TCP keepalive 机制依赖于操作系统的实现,灵活性不够，默认关闭，且默认的 keepalive 心跳时间是 两个小时, 时间较长**。
- 代理(如socks proxy)、或者负载均衡器，会让tcp keep-alive失效

基于此，我们需要**加上应用层的心跳**。应用层的心跳的作用，取决于你想干啥。笔者理解：

- 从服务端的角度来说，主要是为了**资源管理和监控**。例如大家都知道，访问mysql时，如果连接8小时没有请求，服务端就会主动断开连接。这是为了节省连接资源，mysql服务端有一个配置项max_connections，限制最大连接数。如果一个应用建立了连接，又不执行SQL，典型的属于占着茅坑不拉屎，mysql就要把这个连接回收。还可以对连接信息进行监控，例如mysql 中我们可以执行"show processlist”，查看当前有哪些客户端建立了连接。

- 从客户端的角度来说， 主要是为了**保证连接可用**。很多RPC框架，在调用方没有请求发送时，也会定时的发送心跳sql，保证连接可用。例如，很多数据库连接池，都会支持配置一个心跳sql，定时发送到mysql，以保证连接存活。

Netty中也提供了IdleSateHandler，来支持心跳机制。笔者的建议是，如果仅仅只是配置了IdleSateHandler，保证连接可用。有精力的话，server端也加上一个连接监控信息可视化的功能。

> 所以配置中心说得是tcp的长连接？rpc？

- [聊聊 TCP 长连接和心跳那些事](https://www.kancloud.cn/machh03/server/2096494)
