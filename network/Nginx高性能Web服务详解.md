# Nginx高性能Web服务详解

标签（空格分隔）： 未分类

---

# 2.3.5 Nginx服务器的升级

"平滑升级的过程是这样的，Nginx服务接收到USR2信号后，首先将旧的nginx.pid文件（如果在配置文件中更改过这个文件的名字，也是相同的过程）添加后缀oldbin，变为 nginx.pid.oldbin 文件;然后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，**系统中将有新旧两个Nginx服务共同提供Web服务**。之后，**需要向旧的Nginx服务进程发送WINCH信号，使旧的Nginx 服务平滑停止，并删除nginx.pid.oldbin文件**。在发送WINCH信号之前，可以随时停止新的Nginx服务。"


# 第三章 服务器架构初探

3.1模块化的思想哲学

3.2对比其他服务器的做法来对比多进程、多线程、异步。举了几个例子来说明异步、同步、阻塞、非阻塞，但觉得不太形象生动。引出Nginx服务器如何处理请求：多进程与异步非阻塞

3.3章节：介绍Nginx服务器的事件驱动模型select、poll、epoll。虽然不是底层的介绍，但是其**较好地简单明了**的介绍做法、对比优劣。可以作为参考。

3.4：引出架构概览。主进程与子进程的工作、主进程与子进程的交互

子进程与子进程的交互：**主进程设置管道**。指出工作进程的时间循环。

“Nginx 服务器在工作进程中实现了Run-Loop事件处理循环模型的使用，用来处理客户端发来的请求事件。该部分的实现可以说是 Nginx服务器程序实现中最为复杂的部分，包含了**对输入事件繁杂的响应和处理过程，并且这些处理过程都是基于异步任务处理的**。”

> 总的来说，这个章节还是值得多读，虽然只是初探，很多的是点到即止。

> 忘了从哪里看到说到模块的设计要异步化？


# 第12章 Nginx 的启动初始化

12.1.2 启动多进程

"启动多进程的过程和执行一般的多进程程序是一样的，主要使用 fork（）函数产生子进程。主进程就是我们前文提到的master process（主程序），通过一个**for循环来接收和处理外部信号**，对Nginx 服务器的启停进行控制;产生出来的子进程就是我们前文提到的worker process（工作进程），每个工作进程执行一个**for循环来实现Nginx服务器对事件的接收和处理**，以提供Nginx服务器的各项功能。"

> 都需要一个事件循环

"在Nginx服务器升级等情况中，为了保证 Web 服务的平滑过渡，新的Nginx进程需要能够继承旧的Nginx进程打开的socket描述符，继续保证与客户端的网络连接。这些已有的文件描述符存放在环境变量 NGINX中，用冒号或者分号隔开，每个文件描述符是一个整数值。类似的结构如∶ 10000:100001;100004;"

> 与前面的平滑升级与之前讨论的优雅升级过程吻合

> 从源码层次解析了Nginx的初始化过程：cycle结果、处理监听socket（升级）、守护进程。

# 第十三章 Nginx的时间管理

系统调用与库调用

**系统调用的过程**：内核空间、用户空间、系统中断处理等过程

如何获取时间。**vsyscall**。不经过系统中断和陷入内核

缓存时间：写缓存，原子加锁。读缓存，没有加锁。如何避免冲突，slot数组（文中有详细的介绍场景）
volatile：编译器合并优化

更新时间缓存的时机：信号、缓存索引、事件接收。有误差，但是非阻塞，误差很小。可设置SIGALRM的信号间隔时间。

> slot是怎么用的？64个不会导致64个更新间隔么？

> 深入思考如何设计获取系统时间。TODO：可以多搜阅资料，总结专题。

# 第十五章 Nginx工作进程

一个主要工作：创建 Worker Process Cycle 循环机制，启动事件驱动机制。这里的事件就是客户端向 Nginx 服务器发起的网络请求。

15.2.2 建立对各个工作进程的通信管道

这一段源码对各个工作进程的通信管道进行了设置。首先，遍历所有其他的工作进程，调用close0 函数将它们用于监听的channel【1】关闭;然后，遍历结束后再调用closeO函数将自己用于发送消息的channel【0】关闭，只留下 channel【1】监听事件的到来。

相关源码分析：
- 获取连接、添加事件监听任务队列、事件处理函数
- accept_mutex互斥量来避免“惊群现象”
- 与ngx_accept_disabled，保证各个工作进程平滑接受连接请求事件（放弃抢占）
- 接收事件放进该工作进程的事件处理队列
- 事件驱动机制下的事件处理函数，epoll_wait

## 15.3：Nginx 服务器进程间通信

Linux 平台上进程间通信的方式有很多，经典的解决方案包括以下几种∶
- 使用 IPC（包括消息队列、信号量、共享存储）
- 管道
- 套接字 socket

这三种方式中，IPC的三种方式功能很强大，但是**不能支持Nginx 服务器使用的事件驱动模型**。管道简单易用，但是限制也比较多，**一般只是单向通道，只能在父子进程间使用**，即使是*流管道（可以进行双向通信）、命名管道（可以在不相关进程间使用）等*也不能同时支持双向传输和不相关进程之间的通信。因此这两种进程间的通信方式在Nginx服务器实现时是不考虑的。

**套接字socket用于网络通信，同时也能用于系统内进程间通信**，并且这样的通信是**双向通信**，对进程的类型也没有特殊的要求。由于系统内进程的IP地址都是相同的，因此只需使用进程号就可以确定通信的双方。这正好满足了Nginx 服务器进程间通信的要求。而且在Linux平台上有封装好的函数用来实现这一机制，使用起来非常方便。

Linux 平台上使用 socketpair（）函数创建用于进程间双向通信的 socket，

这一对套接字被称为 channel，分别是 channel【0】和channe【1】，一般channel【0】用于向其他进程发送消息，channel【1】用于监听其他进程发送来的消息事件。
> 这里跟15.2.2的监听进程控制事件的管道是有关系吗？双向和单向？一个是工作进程间的通信？一个是主进程与工作进程的通信？

> 通道的使用、ngx_channel_t消息体，复制缓冲区、内存对齐

章节总结：源码分析工作进程的工作流程，重点介绍了运行环境的设置、进程控制事件的接收和处理、网络请求事件的接收和处理。还介绍了 Nginx 主进程和工作进程之间的进程通信机制，其采取的实现方案和源码设计是Nginx **服务器可以高效运行的一个重要原因，具有很有益的参考价值**。


---

总结：前面的理论基础分析，比较偏列举例子。第三章的事件驱动介绍、还有进程间（M-W W-W）的通信也可以值得多读。而且能从源码分析到主进程、工作进程具体是怎么初始化、具体做了什么工作、是怎么进行事件循环的，还是值得深入多读、研究的。而且扩展了平滑升级的概念、Nginx的时间管理。

