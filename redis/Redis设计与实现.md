# Redis设计与实现

标签（空格分隔）： 未分类

---

# 第12章 事件

## 文件事件
套接字、I/O多路复用程序、 文件事件分派器（dispatcher），以及事件处理器

队列：以有序（sequentially）、同步 （synchronously）、**每次一个套接字的方式向文件事件分派器传送套接字**。

然后从源码各个文件的用途说明场景。也有一个完整的客户端与服务器连接事件示例

主要处理器介绍这里有指出：服务器都会一直为客户端套接字的AE_READABLE 事件关联命令请求处理器。但当命令回复发送完毕之后，服务器就会**解除命令回复处理器与客户端套接字的 AE_WRITABLE事件之间的关联**。

## 时间事件
定时事件、周期性事件

实现：服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历 整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。

注意: 它**必须遍历链表中的所有时间事件**，这样才能确保服务器中所有已到达的 时间事件都会被处理。但**正常模式**下的Redis服务器只使用**serverCron一个时间事件**，而**在 benchmark模式下，服务器也只使用两个时间事件**。在这种情况下，服务器**几乎是将无 序链表退化成一个指针来使用**，所以使用无序链表来保存时间事件，并不影响事件执行 的性能。

serverCron函数的主要工作

## 事件的调度与执行
同时存在文件事件与事件事件，重点介绍其如何调度。

aeApiPoll函数的最大阻塞时间由到达时间**最接近当前时间的时间事件决定**，这个方 法既可以**避免服务器对时间事件进行频繁的轮询（忙等待）**，也可以确保aeApiPoll函数**不会阻塞过长时间**。

然后因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时 间事件到达，那么服务器将再次等待并处理文件事件。

因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的 实际处理时间，通常会比时间事件设定的到达时间稍晚一些。

> 处理器要尽可能减少程序的阻塞事件，有需要主动让出执行权，降低造成事件饥饿的可能性。措施：分批次写入、耗时间的任务子线程或者子进程执行

> 小结： 这个章节还是很适合入门的，条理清晰。把之前阅读到的文章提到的知识点都有涉及到，并且帮忙进行梳理。不过具体的源码分析可以自行查阅。
