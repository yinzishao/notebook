Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为**简单动态字符串（simple dynamic string，SDS）的抽象类型**， 并将 SDS 用作 Redis 的默认字符串表示。

在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， **用在一些无须对字符串值进行修改的地方**， 比如打印日志：

```
redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
```

当 Redis 需要的不仅仅是一个字符串字面量， 而是**一个可以被修改的字符串值时**， Redis 就会使用 SDS 来表示字符串值： 比如在 Redis 的数据库里面， 包含字符串值的键值对在底层都是由 SDS 实现的。

除了用来保存数据库中的字符串值之外， **SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区**， 都是由 SDS 实现的， 在之后介绍 AOF 持久化和客户端状态的时候， 我们会看到 SDS 在这两个模块中的应用。


## SDS 与 C 字符串的区别

根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且**字符数组的最后一个元素总是空字符 '\0'** 。

C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在**安全性、效率、以及功能**方面的要求

### 常数复杂度获取字符串长度

因为 C 字符串**并不记录自身的长度信息**， 所以为了获取一个 C 字符串的长度， 程序**必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止**， 这个操作的复杂度为 O(N) 。

和 C 字符串不同， 因为 **SDS 在 len 属性中记录了 SDS 本身的长度**， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。

设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。

通过使用 SDS 而不是 C 字符串， Redis **将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈**。

### 杜绝缓冲区溢出

因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。

将 s1 的内容修改为 "Redis Cluster" ， 但粗心的他却忘了在执行 strcat 之前为 s1 **分配足够的空间**， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中， 导致 s2 保存的内容**被意外地修改**。

与 C 字符串不同， SDS 的**空间分配策略**完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会**先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作**， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。

SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数， **它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面**， 但是在执行拼接操作之前， sdscat 会先检查给定 SDS 的空间是否足够， 如果不够的话， sdscat 就会先扩展 SDS 的空间， 然后才执行拼接操作。

### 减少修改字符串时带来的内存重分配次数

C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：

- 如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过**内存重分配来扩展底层数组的空间大**小 —— 如果忘了这一步就会**产生缓冲区溢出**。
- 如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过**内存重分配来释放字符串不再使用的那部分空间** —— 如果忘了这一步就会**产生内存泄漏**。

因为内存重分配**涉及复杂的算法**， 并且**可能需要执行系统调用**， 所以它通常是一个比较**耗时**的操作：

- 在一般程序中， 如果**修改字符串长度的情况不太常出现**， 那么每次修改都执行一次内存重分配是可以接受的。
- 但是 Redis 作为数据库， 经常被用于**速度要求严苛、数据被频繁修改的场合**， 如果*每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响*。

为了避免 C 字符串的这种缺陷， SDS **通过未使用空间解除了字符串长度和底层数组长度之间的关联**： 在 SDS 中， buf 数组的长度**不一定**就是字符数量加一， 数组里面**可以包含未使用的字节**， 而这些字节的数量就由 SDS 的 **free 属性记录**。

通过**未使用空间**， SDS 实现了**空间预分配和惰性空间释放**两种优化策略。

#### 空间预分配

空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。

其中， 额外分配的未使用空间数量由以下公式决定：

- 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序**分配和 len 属性同样大小的未使用空间**， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。
- 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序**会分配 1 MB 的未使用空间**。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。

通过空间预分配策略， Redis 可以**减少连续执行字符串增长操作所需的内存重分配次数**。

> 先检查未使用空间是否足够, 减少连续执行字符串增长操作所需的内存重分配次数

在扩展 SDS 空间之前， SDS API 会**先检查未使用空间是否足够**， 如果足够的话， API 就会直接使用未使用空间， 而**无须执行内存重分配**。

通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。

#### 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序**并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用**。

注意执行 sdstrim 之后的 SDS 并没有释放多出来的 8 字节空间， 而是将这 8 字节空间作为未使用空间保留在了 SDS 里面， 如果将来要对 SDS 进行增长操作的话， 这些未使用空间就可能会派上用场。

通过惰性空间释放策略， SDS 避免了**缩短字符串时所需的内存重分配操作**， 并为**将来可能有的增长操作提供了优化**。

与此同时， SDS 也提供了相应的 API ， 让我们可以在**有需要时**， **真正地释放** SDS 里面的未使用空间， 所以**不用担心惰性空间释放策略会造成内存浪费**。

### 二进制安全

C 字符串中的字符**必须符合某种编码**（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些**限制使得 C 字符串只能保存文本数据**， 而不能保存像图片、音频、视频、压缩文件这样的**二进制数据**。

虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会**以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据**， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们将 SDS 的 **buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据**。

用 SDS 来保存之前提到的特殊数据格式就没有任何问题， **因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束**

**通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。**

### 兼容部分 C 字符串函数
虽然 SDS 的 API 都是二进制安全的， 但它们**一样遵循 C 字符串以空字符结尾的惯例**： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是**为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数**。

可以重用 <string.h>/strcasecmp 函数， 使用它来对比 SDS 保存的字符串和另一个 C 字符串。还可以将一个保存文本数据的 SDS 作为 strcat 函数的第二个参数， 将 SDS 保存的字符串追加到一个 C 字符串的后面。

通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 <string.h> 函数库， **从而避免了不必要的代码重复**。

## 总结

Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。
比起 C 字符串， SDS 具有以下优点：

- 常数复杂度获取字符串长度。
- 杜绝缓冲区溢出。
- 减少修改字符串长度时所需的内存重分配次数。
- 二进制安全。
- 兼容部分 C 字符串函数。

- [Redis 设计与实现](http://redisbook.com/)
- [redis 为什么把简单的字符串设计成 SDS](https://juejin.cn/post/6930520039560839176)
