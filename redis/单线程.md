# 单线程

- 使用单线程模型能带来更好的可维护性，方便开发和调试；
- 使用单线程模型也能并发的处理客户端的请求；
- Redis 服务中运行的绝大多数操作的**性能瓶颈**都不是 CPU；

## 并发处理
使用单线程模型也**并不意味着程序不能并发的处理任务**，Redis 虽然使用单线程模型处理用户的请求，但是它却使用**I/O 多路复用机制**并发处理来自客户端的多个连接，**同时等待多个连接发送的请求**。

在 I/O 多路复用模型中，最重要的函数调用就是 select 以及类似函数，该方法的能够**同时监控多个文件描述符**（也就是客户端的连接）的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。

使用 I/O 多路复用技术能够极大地减少系统的开销，系统不再需要**额外创建和维护进程和线程**来监听来自客户端的大量连接，减少了服务器的开发成本和维护成本。

简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作**都会在内存中**完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于**网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O**，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。

**频繁**的对线程的**上下文进行切换**可能还会导致性能地急剧下降，这可能会导致我们不仅没有提升请求处理的平均速度，反而进行了负优化，所以这也是为什么 Redis 对于使用多线程技术非常谨慎。

## 总结
Redis 选择使用单线程模型处理客户端的请求主要还是因为**CPU 不是 Redis 服务器的瓶颈**，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在**网络 I/O 操作上**；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些**大键值对的删除操作**，通过多线程非阻塞地释放内存空间也能**减少**对 Redis**主线程阻塞**的时间，提高执行的效率。

> 引入 IO 多路复用可以同时监听多个连接的可读和可写，不需要多个线程来做这个事情，引入了不必要的复杂性

---
# Redis6.0引入了多线程

Q: 看了这篇文章，说到Redis6.0引入了多线程，是为了解决网络的 IO 消耗，能解释下这个具体是什么意思吗?还有这个跟IO多路复用要解决的问题有什么关系呢？

A: 这是一个非常好的问题，I/O 多路复用的主要作用是让我们可以使用一个线程来**监控多个连接**是否可读或者可写，但是从网络另一头发的数据包需要先解**序列化**成 Redis 内部其他模块可以理解的命令，这个过程就是 Redis 6.0 引入**多线程来并发**处理的。

I/O 多路复用模块**收到数据包之后**将其**丢给后面多个 I/O 线程进行解析**，I/O 线程处理结束后，主线程会负责**串行的执行**这些命令，由于向客户端**发回数据包**的过程也是比较耗时的，所以执行之后的结果也会交给多个 I/O 线程发送回客户端。

### 参考链接
- [为什么 Redis 选择单线程模型](https://draveness.me/whys-the-design-redis-single-thread/)
- [评论](https://github.com/draveness/blog-comments/issues/155)


---
# 为啥Redis那么快
> - [Redis哨兵、持久化、主从、手撕LRU](https://juejin.im/post/5dc3a9fbf265da4d3c072eab)

- 完全基于内存，绝大部分请求是**纯粹的内存操作**，非常快速。它的，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
- 数据结构简单，对数据操作也简单，Redis中的**数据结构是专门进行设计**的；
- **采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗**；
- 使用**多路I/O复用模型，非阻塞IO**；
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

## 那他是单线程的，我们现在服务器都是多核的，那不是很浪费？

是的他是单线程的，但是，我们可以通过在单机开多个Redis实例嘛。

> **瓶颈不是CPU，大多都是内存之间的操作。瓶颈是在网络IO**

## Redis is single threaded. How can I exploit multiple CPU / cores?

- [Redis is single threaded. How can I exploit multiple CPU / cores?](https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores)

使用Redis时，CPU成为瓶颈的情况并不常见，因为Redis通常是内存或网络受限的。例如，使用在普通Linux系统上运行的流水线Redis每秒甚至可以发送100万个请求，因此如果您的应用程序**主要使用O（N）或O（log（N））命令，那么它几乎不会占用太多CPU**

但是，为了最大限度地提高CPU使用率，您可以在同一个框中启动多个Redis实例，并将它们视为不同的服务器。在某些情况下，一个单独的框可能是不够的，所以如果你想使用多个cpu，你可以开始考虑一些方法来切分更早。

您可以在Partitioning page中找到有关使用多个Redis实例的更多信息。

然而，在Redis4.0中，我们开始让Redis更加线程化。目前，这仅限于在后台删除对象，以及那些阻止执行的命令。对于未来的版本，计划是让Redis越来越线程化。


---
# Redis读写分离技术解析
> - [Redis读写分离技术解析](https://tech.antfin.com/docs/2/65001)

云数据库Redis版不管主从版还是集群规格，**replica作为备库不对外提供服务**，只有在发生HA的时候，replica提升为master后才承担读写流量。这种架构**读写请求都在master上完成，一致性较高**，但性能受到master数量的限制。经常有用户数据较少，但因为流量或者并发太高而不得不升级到更大的集群规格。

为满足读多写少的业务场景，最大化节约用户成本，云数据库Redis版推出了读写分离规格，为用户提供透明、高可用、高性能、高灵活的读写分离服务。

一般来说，根据master和read-only replica的数据同步方式，可以分为两种架构：星型复制和链式复制。

## 星型复制

星型复制就是将所有的read-only replica**直接**和master保持同步，每个read-only replica之间相互独立，**任何一个节点异常不影响到其他节点**，同时因为复制链比较短，read-only replica上的**复制延迟比较小**。

Redis是单进程单线程模型，主从之间的数据复制也在主线程中处理，read-only replica**数量越多**，数据同步对master的**CPU消耗就越严重**，集群的写入性能会随着read-only replica的增加而降低。此外，星型架构会让**master的出口带宽**随着read-only replica的增加而成倍增长。Master上较高的CPU和网络负载会抵消掉星型复制延迟较低的优势，因此，星型复制架构会带来比较严重的扩展问题，整个集群的性能会受限于master。

## 链式复制

链式复制将所有的read-only replica组织成一个复制链，如下图所示，master**只需要将数据同步给replica和复制链上的第一个**read-only replica。

链式复制解决了星型复制的扩展问题，理论上可以**无限增加**read-only replica的数量，随着节点的增加整个集群的性能也可以基本上呈线性增长。

链式复制的架构下，复制链越长，复制链末端的read-only replica和master之间的**同步延迟就越大**，考虑到**读写分离主要使用在对一致性要求不高的场景下**，这个缺点一般可以接受。但是如果**复制链中的某个节点异常**，会导致下游的所有节点数据都会大幅滞后。更加严重的是这**可能带来全量同步**，并且全量同步将一直传递到复制链的末端，这会对服务带来一定的影响。为了解决这个问题，读写分离的Redis都使用阿里云优化后的**binlog复制版本，最大程度的降低全量同步的概率**。

Redis主从异步复制，从read-only replica中**可能读到旧的数据**，使用读写分离需要业务可以容忍一定程度的数据不一致，后续将会给客户更灵活的配置和更大的自由，例如配置可以容忍的最大延迟时间。

> 主从无法强一致性： You may think at it as a relaxed version of the "C" in the CAP theorem, where consistency is not ensured for a given write, but at least the time window for data loss is restricted to a given number of seconds
